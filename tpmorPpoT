-- Services
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local SoundService = game:GetService("SoundService")
local GuiService = game:GetService("GuiService")

--[[
showNotification("Invalid speed!", true)
]]

local function addlayer()
local CollectionService = game:GetService("CollectionService")
local TweenService = game:GetService("TweenService")

local G2L = {}

-- Players.hmmm5651.PlayerGui.ScreenGui
G2L["ScreenGui_1"] = Instance.new("ScreenGui", game:GetService("Players").LocalPlayer:WaitForChild("PlayerGui"))
G2L["ScreenGui_1"]["DisplayOrder"] = 1
G2L["ScreenGui_1"]["ZIndexBehavior"] = Enum.ZIndexBehavior.Sibling

-- Tags
CollectionService:AddTag(G2L["ScreenGui_1"], [[main]])

-- Players.hmmm5651.PlayerGui.ScreenGui.ImageLabel
G2L["ImageLabel_2"] = Instance.new("ImageLabel", G2L["ScreenGui_1"])
G2L["ImageLabel_2"]["BorderSizePixel"] = 0
G2L["ImageLabel_2"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255)
G2L["ImageLabel_2"]["Image"] = [[rbxassetid://118689412872595]]
G2L["ImageLabel_2"]["Size"] = UDim2.new(0, 182, 0, 118)
G2L["ImageLabel_2"]["BackgroundTransparency"] = 1
G2L["ImageLabel_2"]["Position"] = UDim2.new(0, 20, 0, -32)

-- Set initial transparency for fade in
G2L["ImageLabel_2"].ImageTransparency = 1

-- Fade in animation
local fadeIn = TweenService:Create(
    G2L["ImageLabel_2"],
    TweenInfo.new(0.2, Enum.EasingStyle.Linear),
    {ImageTransparency = 0.5}
)

-- Fade out animation (to use later if needed)
local fadeOut = TweenService:Create(
    G2L["ImageLabel_2"],
    TweenInfo.new(0.2, Enum.EasingStyle.Linear),
    {ImageTransparency = 1}
)

-- Play the fade in animation
fadeIn:Play()

-- Optional: If you want it to automatically fade out after fading in
fadeIn.Completed:Connect(function()
    wait(0.1) -- Wait 1 second before fading out
    fadeOut:Play()
end)

return G2L["ScreenGui_1"], require
end

local function addlayer2()
local CollectionService = game:GetService("CollectionService")
local TweenService = game:GetService("TweenService")

local G2L = {}

-- Players.hmmm5651.PlayerGui.ScreenGui
G2L["ScreenGui_1"] = Instance.new("ScreenGui", game:GetService("Players").LocalPlayer:WaitForChild("PlayerGui"))
G2L["ScreenGui_1"]["DisplayOrder"] = 1
G2L["ScreenGui_1"]["ZIndexBehavior"] = Enum.ZIndexBehavior.Sibling

-- Tags
CollectionService:AddTag(G2L["ScreenGui_1"], [[main]])

-- Players.hmmm5651.PlayerGui.ScreenGui.ImageLabel
G2L["ImageLabel_2"] = Instance.new("ImageLabel", G2L["ScreenGui_1"])
G2L["ImageLabel_2"]["BorderSizePixel"] = 0
G2L["ImageLabel_2"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255)
G2L["ImageLabel_2"]["Image"] = [[rbxassetid://137150573919513]]
G2L["ImageLabel_2"]["Size"] = UDim2.new(0, 156, 0, 158)
G2L["ImageLabel_2"]["BackgroundTransparency"] = 1
G2L["ImageLabel_2"]["Position"] = UDim2.new(0, 16, 0, -54)

-- Set initial transparency for fade in
G2L["ImageLabel_2"].ImageTransparency = 1

-- Fade in animation
local fadeIn = TweenService:Create(
    G2L["ImageLabel_2"],
    TweenInfo.new(3, Enum.EasingStyle.Linear),
    {ImageTransparency = 0.1}
)

-- Play the fade in animation
fadeIn:Play()

return G2L["ScreenGui_1"], require
end

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local player = Players.LocalPlayer

local isMobile = UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled and not UserInputService.GamepadEnabled

local function handleRespawn()
    if isMobile then
        addlayer()
        addlayer2()
    end
end

-- Connect the function to the CharacterAdded event
player.CharacterAdded:Connect(handleRespawn)

-- Also call the function once initially, in case the character is already loaded
handleRespawn()


-- Player references
local localPlayer = Players.LocalPlayer
local character = localPlayer.Character or localPlayer.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")

-- Sound effects
local clickSound = Instance.new("Sound")
clickSound.SoundId = "rbxassetid://177266782" -- Typewriter click
clickSound.Volume = 0.3
clickSound.Parent = SoundService

local errorSound = Instance.new("Sound")
errorSound.SoundId = "rbxassetid://138081500" -- Error beep
errorSound.Volume = 0.4
errorSound.Parent = SoundService

local successSound = Instance.new("Sound")
successSound.SoundId = "rbxassetid://6026984224" -- Success beep
successSound.Volume = 0.4
successSound.Parent = SoundService

-- Command System
local Commands = {}
local CommandOrder = {} -- This will track the order commands were added

-- Type 1: Simple command with description and function
function AddCommand(name, aliases, description, func)
    local commandData = {
        desc = description,
        exec = func,
        hasValue = false,
        hasPlayer = false,
        aliases = type(aliases) == "string" and {aliases} or aliases or {}
    }
    
    -- Add main command
    Commands[name:lower()] = commandData
    table.insert(CommandOrder, name:lower())
    
    -- Add aliases
    for _, alias in ipairs(commandData.aliases) do
        Commands[alias:lower()] = commandData
    end
end

-- Type 2: Command with value input
function AddCommandWithValue(name, valueName, aliases, description, func)
    local commandData = {
        desc = description,
        exec = func,
        hasValue = true,
        valueName = valueName,
        hasPlayer = false,
        aliases = type(aliases) == "string" and {aliases} or aliases or {}
    }
    
    -- Add main command
    Commands[name:lower()] = commandData
    table.insert(CommandOrder, name:lower())
    
    -- Add aliases
    for _, alias in ipairs(commandData.aliases) do
        Commands[alias:lower()] = commandData
    end
end

-- Type 3: Command with player input
function AddCommandWithPlayer(name, aliases, description, func)
    local commandData = {
        desc = description,
        exec = func,
        hasValue = false,
        hasPlayer = true,
        aliases = type(aliases) == "string" and {aliases} or aliases or {}
    }
    
    -- Add main command
    Commands[name:lower()] = commandData
    table.insert(CommandOrder, name:lower())
    
    -- Add aliases
    for _, alias in ipairs(commandData.aliases) do
        Commands[alias:lower()] = commandData
    end
end

-- Type 4: Command with both value and player inputs
function AddCommandWithValueAndPlayer(name, valueName, aliases, description, func)
    local commandData = {
        desc = description,
        exec = func,
        hasValue = true,
        valueName = valueName,
        hasPlayer = true,
        aliases = type(aliases) == "string" and {aliases} or aliases or {}
    }
    
    -- Add main command
    Commands[name:lower()] = commandData
    table.insert(CommandOrder, name:lower())
    
    -- Add aliases
    for _, alias in ipairs(commandData.aliases) do
        Commands[alias:lower()] = commandData
    end
end

-- Alternative simplified command system
function AddCmd(name, description, ...)
    local inputs = {...}
    local hasValue = false
    local valueName = nil
    local hasPlayer = false
    
    for _, input in ipairs(inputs) do
        if input == "value" then
            hasValue = true
            valueName = "value"
        elseif input == "player" then
            hasPlayer = true
        end
    end
    
    return function(func, aliases)
        local commandData = {
            desc = description,
            exec = func,
            hasValue = hasValue,
            valueName = valueName,
            hasPlayer = hasPlayer,
            aliases = type(aliases) == "string" and {aliases} or aliases or {}
        }
        
        -- Add main command
        Commands[name:lower()] = commandData
        table.insert(CommandOrder, name:lower())
        
        -- Add aliases
        for _, alias in ipairs(commandData.aliases) do
            Commands[alias:lower()] = commandData
        end
    end
end

AddCommand("cmds", nil, "Shows all commands", function() return "Opening cmds window..." end)

-- command functionality 

local function Con()
    game:GetService("StarterGui"):SetCore("DevConsoleVisible",true)
    return "Opening Console."
end

local function enableFlight()

local main = Instance.new("ScreenGui")
local Frame = Instance.new("Frame")
local dragHandle = Instance.new("Frame")
local title = Instance.new("TextLabel")
local up = Instance.new("TextButton")
local down = Instance.new("TextButton")
local onof = Instance.new("TextButton")
local plus = Instance.new("TextButton")
local speed = Instance.new("TextBox") -- Changed from TextLabel to TextBox
local mine = Instance.new("TextButton")
local closebutton = Instance.new("TextButton")
local mini = Instance.new("TextButton")
local mini2 = Instance.new("TextButton")

-- Main GUI
main.Name = "main"
main.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
main.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
main.ResetOnSpawn = false

-- Main Frame
Frame.Parent = main
Frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
Frame.BackgroundTransparency = 0.2
Frame.BorderSizePixel = 0
Frame.Position = UDim2.new(0.100320168, 0, 0.379746825, 0)
Frame.Size = UDim2.new(0, 200, 0, 120)
Frame.Active = true
Frame.Draggable = true

-- Add rounded corners
local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(0, 8)
corner.Parent = Frame

-- Add subtle drop shadow
local shadow = Instance.new("UIStroke")
shadow.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
shadow.Color = Color3.fromRGB(60, 60, 60)
shadow.Thickness = 2
shadow.Transparency = 0.7
shadow.Parent = Frame

-- Drag Handle
dragHandle.Name = "DragHandle"
dragHandle.Parent = Frame
dragHandle.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
dragHandle.BorderSizePixel = 0
dragHandle.Size = UDim2.new(1, 0, 0, 30)
dragHandle.ZIndex = 2

-- Drag handle corners
local dragCorner = Instance.new("UICorner")
dragCorner.CornerRadius = UDim.new(0, 8)
dragCorner.Parent = dragHandle

-- Title
title.Name = "Title"
title.Parent = dragHandle
title.BackgroundTransparency = 1
title.Position = UDim2.new(0, 10, 0, 0)
title.Size = UDim2.new(1, -10, 1, 0)
title.Font = Enum.Font.Arcade
title.Text = "FLYGUI"
title.TextColor3 = Color3.fromRGB(0, 255, 0)
title.TextSize = 14
title.TextXAlignment = Enum.TextXAlignment.Left

-- Close Button
closebutton.Name = "Close"
closebutton.Parent = dragHandle
closebutton.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
closebutton.BackgroundTransparency = 0.8
closebutton.Position = UDim2.new(1, -30, 0, 2)
closebutton.Size = UDim2.new(0, 26, 0, 26)
closebutton.Font = Enum.Font.Arcade
closebutton.Text = "X"
closebutton.TextColor3 = Color3.fromRGB(255, 0, 0)
closebutton.TextSize = 16
closebutton.ZIndex = 3

-- Close button corner
local closeCorner = Instance.new("UICorner")
closeCorner.CornerRadius = UDim.new(0, 6)
closeCorner.Parent = closebutton

-- Minimize Button
mini.Name = "minimize"
mini.Parent = dragHandle
mini.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
mini.BackgroundTransparency = 0.8
mini.Position = UDim2.new(1, -60, 0, 2)
mini.Size = UDim2.new(0, 26, 0, 26)
mini.Font = Enum.Font.Arcade
mini.Text = "-"
mini.TextColor3 = Color3.fromRGB(0, 255, 0)
mini.TextSize = 20
mini.ZIndex = 3

-- Minimize button corner
local miniCorner = Instance.new("UICorner")
miniCorner.CornerRadius = UDim.new(0, 6)
miniCorner.Parent = mini

-- Restore Button (initially hidden)
mini2.Name = "minimize2"
mini2.Parent = dragHandle
mini2.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
mini2.BackgroundTransparency = 0.8
mini2.Position = UDim2.new(1, -60, 0, 2)
mini2.Size = UDim2.new(0, 26, 0, 26)
mini2.Font = Enum.Font.Arcade
mini2.Text = "+"
mini2.TextColor3 = Color3.fromRGB(0, 255, 0)
mini2.TextSize = 16
mini2.Visible = false
mini2.ZIndex = 3

-- Restore button corner
local mini2Corner = Instance.new("UICorner")
mini2Corner.CornerRadius = UDim.new(0, 6)
mini2Corner.Parent = mini2

-- Up Button
up.Name = "up"
up.Parent = Frame
up.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
up.Position = UDim2.new(0.05, 0, 0.35, 0)
up.Size = UDim2.new(0.4, 0, 0.25, 0)
up.Font = Enum.Font.Arcade
up.Text = "UP"
up.TextColor3 = Color3.fromRGB(0, 255, 0)
up.TextSize = 14

-- Up button corner and hover effects
local upCorner = Instance.new("UICorner")
upCorner.CornerRadius = UDim.new(0, 6)
upCorner.Parent = up

up.MouseEnter:Connect(function()
    up.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
end)

up.MouseLeave:Connect(function()
    up.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
end)

-- Down Button
down.Name = "down"
down.Parent = Frame
down.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
down.Position = UDim2.new(0.55, 0, 0.35, 0)
down.Size = UDim2.new(0.4, 0, 0.25, 0)
down.Font = Enum.Font.Arcade
down.Text = "DOWN"
down.TextColor3 = Color3.fromRGB(00, 255, 0)
down.TextSize = 14

-- Down button corner and hover effects
local downCorner = Instance.new("UICorner")
downCorner.CornerRadius = UDim.new(0, 6)
downCorner.Parent = down

down.MouseEnter:Connect(function()
    down.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
end)

down.MouseLeave:Connect(function()
    down.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
end)

-- Fly Toggle Button
onof.Name = "onof"
onof.Parent = Frame
onof.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
onof.Position = UDim2.new(0.55, 0, 0.65, 0)
onof.Size = UDim2.new(0.4, 0, 0.25, 0)
onof.Font = Enum.Font.Arcade
onof.Text = "FLY"
onof.TextColor3 = Color3.fromRGB(0, 255, 0)
onof.TextSize = 14

-- Fly button corner and hover effects
local onofCorner = Instance.new("UICorner")
onofCorner.CornerRadius = UDim.new(0, 6)
onofCorner.Parent = onof

onof.MouseEnter:Connect(function()
    onof.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
end)

onof.MouseLeave:Connect(function()
    onof.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
end)

-- Speed Display (now a TextBox for input)
speed.Name = "speed"
speed.Parent = Frame
speed.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
speed.Position = UDim2.new(0.3, 0, 0.65, 0)
speed.Size = UDim2.new(0.2, 0, 0.25, 0)
speed.Font = Enum.Font.Arcade
speed.Text = "1"
speed.PlaceholderText = "Speed"
speed.TextColor3 = Color3.fromRGB(0, 255, 255)
speed.TextSize = 14
speed.ClearTextOnFocus = false
speed.TextScaled = false
speed.TextWrapped = true

-- Speed display corner
local speedCorner = Instance.new("UICorner")
speedCorner.CornerRadius = UDim.new(0, 6)
speedCorner.Parent = speed

-- Plus Button
plus.Name = "plus"
plus.Parent = Frame
plus.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
plus.Position = UDim2.new(0.05, 0, 0.65, 0)
plus.Size = UDim2.new(0.2, 0, 0.25, 0)
plus.Font = Enum.Font.Arcade
plus.Text = "+"
plus.TextColor3 = Color3.fromRGB(0, 255, 0)
plus.TextSize = 16

-- Plus button corner and hover effects
local plusCorner = Instance.new("UICorner")
plusCorner.CornerRadius = UDim.new(0, 6)
plusCorner.Parent = plus

plus.MouseEnter:Connect(function()
    plus.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
end)

plus.MouseLeave:Connect(function()
    plus.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
end)

-- Minus Button
mine.Name = "mine"
mine.Parent = Frame
mine.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
mine.Position = UDim2.new(0.05, 0, 0.65, 0)
mine.Size = UDim2.new(0.2, 0, 0.25, 0)
mine.Font = Enum.Font.Arcade
mine.Text = "-"
mine.TextColor3 = Color3.fromRGB(0, 255, 0)
mine.TextSize = 16
mine.Visible = false -- Initially hidden since plus is shown first

-- Minus button corner and hover effects
local mineCorner = Instance.new("UICorner")
mineCorner.CornerRadius = UDim.new(0, 6)
mineCorner.Parent = mine

mine.MouseEnter:Connect(function()
    mine.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
end)

mine.MouseLeave:Connect(function()
    mine.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
end)

-- =============================================
-- IMPROVED DRAGGING IMPLEMENTATION
-- =============================================

local UserInputService = game:GetService("UserInputService")
local dragging, dragInput, dragStart, startPos

local function update(input)
	if not dragging then return end
	local delta = input.Position - dragStart
	Frame.Position = UDim2.new(
		startPos.X.Scale,
		startPos.X.Offset + delta.X,
		startPos.Y.Scale,
		startPos.Y.Offset + delta.Y
	)
end

local function startDrag(input)
	dragging = true
	dragStart = input.Position
	startPos = Frame.Position

	input.Changed:Connect(function()
		if input.UserInputState == Enum.UserInputState.End then
			dragging = false
		end
	end)
end

for _, element in pairs({dragHandle, title}) do
	element.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			startDrag(input)
		end
	end)
end

UserInputService.InputChanged:Connect(function(input)
	if input == dragInput and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
		update(input)
	end
end)

-- Set dragInput on InputBegan
dragHandle.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
		dragInput = input
	end
end)

-- =============================================
-- REST OF THE FUNCTIONALITY
-- =============================================

local speeds = 1
local speaker = game:GetService("Players").LocalPlayer
local chr = game.Players.LocalPlayer.Character
local hum = chr and chr:FindFirstChildWhichIsA("Humanoid")
local nowe = false

-- Function to get current speed value
local function getSpeed()
    local num = tonumber(speed.Text)
    if num and num > 0 then
        return num
    else
        speed.Text = "1"
        return 1
    end
end

-- Function to set speed value
local function setSpeed(value)
    speeds = value
    speed.Text = tostring(value)
end

-- Update speed when text changes
speed.FocusLost:Connect(function(enterPressed)
    local num = tonumber(speed.Text)
    if num and num > 0 then
        speeds = num
    else
        speed.Text = tostring(speeds)
    end
end)

onof.MouseButton1Down:connect(function()
    if nowe == true then
        nowe = false
        onof.BackgroundColor3 = Color3.fromRGB(80, 60, 60)
        speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Climbing,true)
        speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown,true)
        speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Flying,true)
        speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Freefall,true)
        speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.GettingUp,true)
        speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping,true)
        speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Landed,true)
        speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Physics,true)
        speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.PlatformStanding,true)
        speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Ragdoll,true)
        speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Running,true)
        speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.RunningNoPhysics,true)
        speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated,true)
        speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.StrafingNoPhysics,true)
        speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Swimming,true)
        speaker.Character.Humanoid:ChangeState(Enum.HumanoidStateType.RunningNoPhysics)
    else
        nowe = true
        onof.BackgroundColor3 = Color3.fromRGB(60, 80, 60)
        for i = 1, getSpeed() do
            spawn(function()
                local hb = game:GetService("RunService").Heartbeat             
                tpwalking = true
                local chr = game.Players.LocalPlayer.Character
                local hum = chr and chr:FindFirstChildWhichIsA("Humanoid")
                while tpwalking and hb:Wait() and chr and hum and hum.Parent do
                    if hum.MoveDirection.Magnitude > 0 then
                        chr:TranslateBy(hum.MoveDirection)
                    end
                end
            end)
        end
        game.Players.LocalPlayer.Character.Animate.Disabled = true
        local Char = game.Players.LocalPlayer.Character
        local Hum = Char:FindFirstChildOfClass("Humanoid") or Char:FindFirstChildOfClass("AnimationController")
        for i,v in next, Hum:GetPlayingAnimationTracks() do
            v:AdjustSpeed(0)
        end
        speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Climbing,false)
        speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown,false)
        speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Flying,false)
        speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Freefall,false)
        speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.GettingUp,false)
        speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping,false)
        speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Landed,false)
        speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Physics,false)
        speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.PlatformStanding,false)
        speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Ragdoll,false)
        speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Running,false)
        speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.RunningNoPhysics,false)
        speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated,false)
        speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.StrafingNoPhysics,false)
        speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Swimming,false)
        speaker.Character.Humanoid:ChangeState(Enum.HumanoidStateType.Swimming)
    end
    
    if game:GetService("Players").LocalPlayer.Character:FindFirstChildOfClass("Humanoid").RigType == Enum.HumanoidRigType.R6 then
        local plr = game.Players.LocalPlayer
        local torso = plr.Character.Torso
        local flying = true
        local deb = true
        local ctrl = {f = 0, b = 0, l = 0, r = 0}
        local lastctrl = {f = 0, b = 0, l = 0, r = 0}
        local maxspeed = getSpeed() * 10 -- Scale the speed
        local speed = 0
        local bg = Instance.new("BodyGyro", torso)
        bg.P = 9e4
        bg.maxTorque = Vector3.new(9e9, 9e9, 9e9)
        bg.cframe = torso.CFrame
        local bv = Instance.new("BodyVelocity", torso)
        bv.velocity = Vector3.new(0,0.1,0)
        bv.maxForce = Vector3.new(9e9, 9e9, 9e9)
        if nowe == true then
            plr.Character.Humanoid.PlatformStand = true
        end
        while nowe == true or game:GetService("Players").LocalPlayer.Character.Humanoid.Health == 0 do
            game:GetService("RunService").RenderStepped:Wait()
            if ctrl.l + ctrl.r ~= 0 or ctrl.f + ctrl.b ~= 0 then
                speed = speed+.5+(speed/maxspeed)
                if speed > maxspeed then
                    speed = maxspeed
                end
            elseif not (ctrl.l + ctrl.r ~= 0 or ctrl.f + ctrl.b ~= 0) and speed ~= 0 then
                speed = speed-1
                if speed < 0 then
                    speed = 0
                end
            end
            if (ctrl.l + ctrl.r) ~= 0 or (ctrl.f + ctrl.b) ~= 0 then
                bv.velocity = ((game.Workspace.CurrentCamera.CoordinateFrame.lookVector * (ctrl.f+ctrl.b)) + ((game.Workspace.CurrentCamera.CoordinateFrame * CFrame.new(ctrl.l+ctrl.r,(ctrl.f+ctrl.b)*.2,0).p) - game.Workspace.CurrentCamera.CoordinateFrame.p))*speed
                lastctrl = {f = ctrl.f, b = ctrl.b, l = ctrl.l, r = ctrl.r}
            elseif (ctrl.l + ctrl.r) == 0 and (ctrl.f + ctrl.b) == 0 and speed ~= 0 then
                bv.velocity = ((game.Workspace.CurrentCamera.CoordinateFrame.lookVector * (lastctrl.f+lastctrl.b)) + ((game.Workspace.CurrentCamera.CoordinateFrame * CFrame.new(lastctrl.l+lastctrl.r,(lastctrl.f+lastctrl.b)*.2,0).p) - game.Workspace.CurrentCamera.CoordinateFrame.p))*speed
            else
                bv.velocity = Vector3.new(0,0,0)
            end
            bg.cframe = game.Workspace.CurrentCamera.CoordinateFrame * CFrame.Angles(-math.rad((ctrl.f+ctrl.b)*50*speed/maxspeed),0,0)
        end
        ctrl = {f = 0, b = 0, l = 0, r = 0}
        lastctrl = {f = 0, b = 0, l = 0, r = 0}
        speed = 0
        bg:Destroy()
        bv:Destroy()
        plr.Character.Humanoid.PlatformStand = false
        game.Players.LocalPlayer.Character.Animate.Disabled = false
        tpwalking = false
    else
        local plr = game.Players.LocalPlayer
        local UpperTorso = plr.Character.UpperTorso
        local flying = true
        local deb = true
        local ctrl = {f = 0, b = 0, l = 0, r = 0}
        local lastctrl = {f = 0, b = 0, l = 0, r = 0}
        local maxspeed = getSpeed() * 10 -- Scale the speed
        local speed = 0
        local bg = Instance.new("BodyGyro", UpperTorso)
        bg.P = 9e4
        bg.maxTorque = Vector3.new(9e9, 9e9, 9e9)
        bg.cframe = UpperTorso.CFrame
        local bv = Instance.new("BodyVelocity", UpperTorso)
        bv.velocity = Vector3.new(0,0.1,0)
        bv.maxForce = Vector3.new(9e9, 9e9, 9e9)
        if nowe == true then
            plr.Character.Humanoid.PlatformStand = true
        end
        while nowe == true or game:GetService("Players").LocalPlayer.Character.Humanoid.Health == 0 do
            wait()
            if ctrl.l + ctrl.r ~= 0 or ctrl.f + ctrl.b ~= 0 then
                speed = speed+.5+(speed/maxspeed)
                if speed > maxspeed then
                    speed = maxspeed
                end
            elseif not (ctrl.l + ctrl.r ~= 0 or ctrl.f + ctrl.b ~= 0) and speed ~= 0 then
                speed = speed-1
                if speed < 0 then
                    speed = 0
                end
            end
            if (ctrl.l + ctrl.r) ~= 0 or (ctrl.f + ctrl.b) ~= 0 then
                bv.velocity = ((game.Workspace.CurrentCamera.CoordinateFrame.lookVector * (ctrl.f+ctrl.b)) + ((game.Workspace.CurrentCamera.CoordinateFrame * CFrame.new(ctrl.l+ctrl.r,(ctrl.f+ctrl.b)*.2,0).p) - game.Workspace.CurrentCamera.CoordinateFrame.p))*speed
                lastctrl = {f = ctrl.f, b = ctrl.b, l = ctrl.l, r = ctrl.r}
            elseif (ctrl.l + ctrl.r) == 0 and (ctrl.f + ctrl.b) == 0 and speed ~= 0 then
                bv.velocity = ((game.Workspace.CurrentCamera.CoordinateFrame.lookVector * (lastctrl.f+lastctrl.b)) + ((game.Workspace.CurrentCamera.CoordinateFrame * CFrame.new(lastctrl.l+lastctrl.r,(lastctrl.f+lastctrl.b)*.2,0).p) - game.Workspace.CurrentCamera.CoordinateFrame.p))*speed
            else
                bv.velocity = Vector3.new(0,0,0)
            end
            bg.cframe = game.Workspace.CurrentCamera.CoordinateFrame * CFrame.Angles(-math.rad((ctrl.f+ctrl.b)*50*speed/maxspeed),0,0)
        end
        ctrl = {f = 0, b = 0, l = 0, r = 0}
        lastctrl = {f = 0, b = 0, l = 0, r = 0}
        speed = 0
        bg:Destroy()
        bv:Destroy()
        plr.Character.Humanoid.PlatformStand = false
        game.Players.LocalPlayer.Character.Animate.Disabled = false
        tpwalking = false
    end
end)

local tis
up.MouseButton1Down:connect(function()
    tis = up.MouseEnter:connect(function()
        while tis do
            wait()
            game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame * CFrame.new(0,1,0)
        end
    end)
end)

up.MouseLeave:connect(function()
    if tis then
        tis:Disconnect()
        tis = nil
    end
end)

local dis
down.MouseButton1Down:connect(function()
    dis = down.MouseEnter:connect(function()
        while dis do
            wait()
            game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame * CFrame.new(0,-1,0)
        end
    end)
end)

down.MouseLeave:connect(function()
    if dis then
        dis:Disconnect()
        dis = nil
    end
end)

game:GetService("Players").LocalPlayer.CharacterAdded:Connect(function(char)
    wait(0.7)
    game.Players.LocalPlayer.Character.Humanoid.PlatformStand = false
    game.Players.LocalPlayer.Character.Animate.Disabled = false
end)

plus.MouseButton1Down:connect(function()
    setSpeed(getSpeed() + 1)
    if nowe == true then
        tpwalking = false
        for i = 1, getSpeed() do
            spawn(function()
                local hb = game:GetService("RunService").Heartbeat             
                tpwalking = true
                local chr = game.Players.LocalPlayer.Character
                local hum = chr and chr:FindFirstChildWhichIsA("Humanoid")
                while tpwalking and hb:Wait() and chr and hum and hum.Parent do
                    if hum.MoveDirection.Magnitude > 0 then
                        chr:TranslateBy(hum.MoveDirection)
                    end
                end
            end)
        end
    end
end)

mine.MouseButton1Down:connect(function()
    if getSpeed() == 1 then
        speed.Text = 'cannot be < 1'
        wait(1)
        speed.Text = tostring(speeds)
    else
        setSpeed(getSpeed() - 1)
        if nowe == true then
            tpwalking = false
            for i = 1, getSpeed() do
                spawn(function()
                    local hb = game:GetService("RunService").Heartbeat             
                    tpwalking = true
                    local chr = game.Players.LocalPlayer.Character
                    local hum = chr and chr:FindFirstChildWhichIsA("Humanoid")
                    while tpwalking and hb:Wait() and chr and hum and hum.Parent do
                        if hum.MoveDirection.Magnitude > 0 then
                            chr:TranslateBy(hum.MoveDirection)
                        end
                    end
                end)
            end
        end
    end
end)

closebutton.MouseButton1Click:Connect(function()
    main:Destroy()
end)

mini.MouseButton1Click:Connect(function()
    up.Visible = false
    down.Visible = false
    onof.Visible = false
    plus.Visible = false
    speed.Visible = false
    mine.Visible = false
    mini.Visible = false
    mini2.Visible = true
    Frame.Size = UDim2.new(0, 200, 0, 30)
    Frame.BackgroundTransparency = 0.5
end)

mini2.MouseButton1Click:Connect(function()
    up.Visible = true
    down.Visible = true
    onof.Visible = true
    plus.Visible = true
    speed.Visible = true
    mine.Visible = true
    mini.Visible = true
    mini2.Visible = false
    Frame.Size = UDim2.new(0, 200, 0, 120)
    Frame.BackgroundTransparency = 0
end)

return "Opened 'Fly' Window."
end


local function plrz()

local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local player = game.Players.LocalPlayer

local gui = Instance.new("ScreenGui")
gui.Name = "PlayerListGUI"
gui.ResetOnSpawn = false
gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

-- Main Frame
local mainFrame = Instance.new("Frame")
mainFrame.Name = "MainFrame"
mainFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
mainFrame.BorderColor3 = Color3.fromRGB(27, 42, 53)
mainFrame.BackgroundTransparency = 0.2
mainFrame.BorderSizePixel = 2
mainFrame.Position = UDim2.new(0.05, 0, 0.05, 0)
mainFrame.Size = UDim2.new(0, 200, 0, 300)
mainFrame.ClipsDescendants = true
mainFrame.Parent = gui

-- Corner rounding
local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(0, 6)
corner.Parent = mainFrame

-- Drop shadow
local shadow = Instance.new("ImageLabel")
shadow.Name = "Shadow"
shadow.Image = "rbxassetid://1316045217"
shadow.ImageColor3 = Color3.new(0, 0, 0)
shadow.ImageTransparency = 0.2
shadow.ScaleType = Enum.ScaleType.Slice
shadow.SliceCenter = Rect.new(10, 10, 118, 118)
shadow.Size = UDim2.new(1, 10, 1, 10)
shadow.Position = UDim2.new(0, -5, 0, -5)
shadow.BackgroundTransparency = 1
shadow.Parent = mainFrame
shadow.ZIndex = -1

-- Title Bar
local titleBar = Instance.new("Frame")
titleBar.Name = "TitleBar"
titleBar.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
titleBar.BorderSizePixel = 0
titleBar.Size = UDim2.new(1, 0, 0, 30)
titleBar.Parent = mainFrame

local titleCorner = Instance.new("UICorner")
titleCorner.CornerRadius = UDim.new(0, 6)
titleCorner.Parent = titleBar

local titleText = Instance.new("TextLabel")
titleText.Name = "TitleText"
titleText.BackgroundTransparency = 1
titleText.Position = UDim2.new(0, 10, 0, 0)
titleText.Size = UDim2.new(0.6, 0, 1, 0)
titleText.Font = Enum.Font.Arcade
titleText.Text = "Player List"
titleText.TextColor3 = Color3.fromRGB(0, 255, 0)
titleText.TextSize = 14
titleText.TextXAlignment = Enum.TextXAlignment.Left
titleText.Parent = titleBar

-- Minimize Button
local minimizeButton = Instance.new("TextButton")
minimizeButton.Name = "MinimizeButton"
minimizeButton.BackgroundTransparency = 1
minimizeButton.Position = UDim2.new(0.7, 0, 0, 0)
minimizeButton.Size = UDim2.new(0.15, 0, 1, 0)
minimizeButton.Font = Enum.Font.Arcade
minimizeButton.Text = "_"
minimizeButton.TextColor3 = Color3.fromRGB(0, 255, 0)
minimizeButton.TextSize = 16
minimizeButton.Parent = titleBar

-- Close Button
local closeButton = Instance.new("TextButton")
closeButton.Name = "CloseButton"
closeButton.BackgroundTransparency = 1
closeButton.Position = UDim2.new(0.85, 0, 0, 0)
closeButton.Size = UDim2.new(0.15, 0, 1, 0)
closeButton.Font = Enum.Font.Arcade
closeButton.Text = "X"
closeButton.TextColor3 = Color3.fromRGB(255, 0, 0)
closeButton.TextSize = 14
closeButton.Parent = titleBar

-- Button hover effects
local function setupButtonHover(button)
    local originalTextColor = button.TextColor3
    local originalSize = button.Size
    
    button.MouseEnter:Connect(function()
        local tween = TweenService:Create(
            button,
            TweenInfo.new(0.2),
            {TextColor3 = Color3.fromRGB(255, 255, 255)}
        )
        tween:Play()
    end)
    
    button.MouseLeave:Connect(function()
        local tween = TweenService:Create(
            button,
            TweenInfo.new(0.2),
            {TextColor3 = originalTextColor}
        )
        tween:Play()
    end)
end

setupButtonHover(minimizeButton)
setupButtonHover(closeButton)

-- Scrolling Frame for Players
local scrollFrame = Instance.new("ScrollingFrame")
scrollFrame.Name = "PlayerScrollFrame"
scrollFrame.BackgroundTransparency = 1
scrollFrame.Position = UDim2.new(0, 0, 0, 30)
scrollFrame.Size = UDim2.new(1, 0, 1, -30)
scrollFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
scrollFrame.ScrollBarThickness = 5
scrollFrame.Parent = mainFrame

local listLayout = Instance.new("UIListLayout")
listLayout.Padding = UDim.new(0, 5)
listLayout.Parent = scrollFrame

-- Function to update player list
local function updatePlayerList()
    for _, child in ipairs(scrollFrame:GetChildren()) do
        if child:IsA("Frame") then
            child:Destroy()
        end
    end
    
    local playerCount = 0
    for _, plr in ipairs(Players:GetPlayers()) do
        playerCount = playerCount + 1
        
        local playerFrame = Instance.new("Frame")
        playerFrame.Name = plr.Name
        playerFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
        playerFrame.BackgroundTransparency = 0.5
        playerFrame.Size = UDim2.new(1, -10, 0, 30)
        playerFrame.Position = UDim2.new(0, 5, 0, (playerCount-1) * 35)
        
        -- Animation for when player frame is added
        playerFrame.Size = UDim2.new(0, 0, 0, 30)
        playerFrame.Position = UDim2.new(0.5, 0, 0, (playerCount-1) * 35)
        
        local expandTween = TweenService:Create(
            playerFrame,
            TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
            {Size = UDim2.new(1, -10, 0, 30), Position = UDim2.new(0, 5, 0, (playerCount-1) * 35)}
        )
        expandTween:Play()
        
        local playerCorner = Instance.new("UICorner")
        playerCorner.CornerRadius = UDim.new(0, 4)
        playerCorner.Parent = playerFrame
        
        local username = Instance.new("TextLabel")
        username.Name = "Username"
        username.BackgroundTransparency = 1
        username.Position = UDim2.new(0, 10, 0, 0)
        username.Size = UDim2.new(0.7, 0, 1, 0)
        username.Font = Enum.Font.Arcade
        username.Text = plr.Name
        username.TextColor3 = Color3.fromRGB(0, 170, 220)
        username.TextSize = 12
        username.TextXAlignment = Enum.TextXAlignment.Left
        username.Parent = playerFrame
        
        local copyButton = Instance.new("TextButton")
        copyButton.Name = "CopyButton"
        copyButton.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
        copyButton.Position = UDim2.new(0.7, 5, 0.15, 0)
        copyButton.Size = UDim2.new(0.25, 0, 0.7, 0)
        copyButton.Font = Enum.Font.Arcade
        copyButton.Text = "Copy"
        copyButton.TextColor3 = Color3.fromRGB(0, 255, 0)
        copyButton.TextSize = 12
        
        local buttonCorner = Instance.new("UICorner")
        buttonCorner.CornerRadius = UDim.new(0, 4)
        buttonCorner.Parent = copyButton
        
        -- Button hover effect
        copyButton.MouseEnter:Connect(function()
            local tween = TweenService:Create(
                copyButton,
                TweenInfo.new(0.2),
                {BackgroundColor3 = Color3.fromRGB(50, 50, 50), TextColor3 = Color3.fromRGB(255, 255, 255)}
            )
            tween:Play()
        end)
        
        copyButton.MouseLeave:Connect(function()
            local tween = TweenService:Create(
                copyButton,
                TweenInfo.new(0.2),
                {BackgroundColor3 = Color3.fromRGB(40, 40, 40), TextColor3 = Color3.fromRGB(200, 200, 200)}
            )
            tween:Play()
        end)
        
        copyButton.MouseButton1Click:Connect(function()
            setclipboard(plr.Name)
            
            -- Animation when copied
            local originalText = copyButton.Text
            local originalSize = copyButton.Size
            
            local tween1 = TweenService:Create(
                copyButton,
                TweenInfo.new(0.1),
                {Size = UDim2.new(0.23, 0, 0.65, 0), Text = "Copied!"}
            )
            
            local tween2 = TweenService:Create(
                copyButton,
                TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0.1),
                {Size = originalSize}
            )
            
            tween1:Play()
            tween1.Completed:Connect(function()
                tween2:Play()
            end)
            
            wait(1.5)
            copyButton.Text = originalText
        end)
        
        copyButton.Parent = playerFrame
        playerFrame.Parent = scrollFrame
    end
    
    scrollFrame.CanvasSize = UDim2.new(0, 0, 0, playerCount * 35)
end

-- Draggable functionality
local dragging
local dragInput
local dragStart
local startPos

local function update(input)
    local delta = input.Position - dragStart
    local newPos = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
    mainFrame.Position = newPos
end

titleBar.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = mainFrame.Position
        
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

titleBar.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
        dragInput = input
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if input == dragInput and dragging then
        update(input)
    end
end)

-- Minimize functionality
local isMinimized = false
minimizeButton.MouseButton1Click:Connect(function()
    isMinimized = not isMinimized
    if isMinimized then
        local tween = TweenService:Create(
            mainFrame,
            TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
            {Size = UDim2.new(0, 200, 0, 30)}
        )
        tween:Play()
        minimizeButton.Text = "+"
    else
        local tween = TweenService:Create(
            mainFrame,
            TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
            {Size = UDim2.new(0, 200, 0, 300)}
        )
        tween:Play()
        minimizeButton.Text = "_"
    end
end)

-- Close functionality
closeButton.MouseButton1Click:Connect(function()
    local tween = TweenService:Create(
        mainFrame,
        TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
        {Size = UDim2.new(0, 200, 0, 0)}
    )
    tween:Play()
    
    tween.Completed:Connect(function()
        gui:Destroy()
    end)
end)

-- Initial setup
Players.PlayerAdded:Connect(updatePlayerList)
Players.PlayerRemoving:Connect(updatePlayerList)
updatePlayerList()

gui.Parent = player:WaitForChild("PlayerGui")

end

-- invis
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()

-- Track current character and connections
local currentCharacter = character
local characterAddedConn = nil
local humanoidDiedConn = nil

local function setTransparency(character, transparency)
    for _, part in pairs(character:GetDescendants()) do
        if part:IsA("BasePart") or part:IsA("Decal") then
            part.Transparency = transparency
        end
    end
end

local function cleanupInvisibility()
    local invisChair = workspace:FindFirstChild("invischair")
    if invisChair then
        invisChair:Destroy()
    end
end

local function setupCharacter(newCharacter)
    -- Clean up previous character connections
    if humanoidDiedConn then
        humanoidDiedConn:Disconnect()
        humanoidDiedConn = nil
    end
    
    -- Set up new character
    currentCharacter = newCharacter
    
    -- Connect to humanoid's death event
    local humanoid = newCharacter:WaitForChild("Humanoid")
    humanoidDiedConn = humanoid.Died:Connect(function()
        cleanupInvisibility()
    end)
end

-- Initial character setup
setupCharacter(character)

-- Connect to CharacterAdded for respawns
characterAddedConn = player.CharacterAdded:Connect(function(newCharacter)
    cleanupInvisibility()
    setupCharacter(newCharacter)
end)

function invis2()
    if not currentCharacter or not currentCharacter:FindFirstChild("HumanoidRootPart") then
        showNotification("Invisibility: FAILED!", true)
    end
    
    cleanupInvisibility() -- Clean up any existing invisibility
    
    local savedpos = currentCharacter:WaitForChild("HumanoidRootPart").CFrame
    task.wait()
    currentCharacter:MoveTo(Vector3.new(-25.95, 84, 3537.55))
    task.wait(0.15)

    local seat = Instance.new("Seat")
    seat.Name = "invischair"
    seat.Anchored = false
    seat.CanCollide = false
    seat.Transparency = 1
    seat.Position = Vector3.new(-25.95, 84, 3537.55)
    seat.Parent = workspace

    local weld = Instance.new("Weld", seat)
    weld.Part0 = seat
    weld.Part1 = currentCharacter:FindFirstChild("Torso") or currentCharacter:FindFirstChild("UpperTorso")

    task.wait()
    seat.CFrame = savedpos
    setTransparency(currentCharacter, 0.5)
    return "Invisibility: TRUE"
end

function vis2()
    cleanupInvisibility()
    
    if currentCharacter then
        setTransparency(currentCharacter, 0)
    end
    
    return "Invisibility: FALSE"
end

-- Cleanup when script is destroyed
local function onDestroy()
    cleanupInvisibility()
    if characterAddedConn then
        characterAddedConn:Disconnect()
    end
    if humanoidDiedConn then
        humanoidDiedConn:Disconnect()
    end
end

local TeleportTime = 0.2
local AutoStopTime = 5 -- seconds to run before auto-stopping

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")

local localPlayer = Players.LocalPlayer

local function resetCameraSubject()
    if workspace.CurrentCamera and localPlayer.Character then
        local humanoid = localPlayer.Character:FindFirstChildWhichIsA("Humanoid")
        if humanoid then
            workspace.CurrentCamera.CameraSubject = humanoid
        end
    end
end

local function StartAB()
    local plr = Players.LocalPlayer
    local character = plr.Character or plr.CharacterAdded:Wait()
    local hrp = character:WaitForChild("HumanoidRootPart")
    
    local lastPos = hrp.Position
    local targetPos = Vector3.new(0, -80000000, 0)
    local db = false
    local velConn
    
    -- Clean up any existing Gaze parts
    for _, gaze in ipairs(workspace:GetDescendants()) do
        if gaze:IsA("Part") and gaze.Name == "Gaze" and gaze.Transparency == 0.5 then
            workspace.Gaze:Destroy()
        end
    end

    local function createTween(targetCFrame)
        local tweenInfo = TweenInfo.new(TeleportTime, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)
        return TweenService:Create(hrp, tweenInfo, {CFrame = targetCFrame})
    end

    local function startVelLoop()
        velConn = RunService.Heartbeat:Connect(function()
            hrp.Velocity = Vector3.new(0, 0, 0)
        end)
    end

    local function stopScript()
        if db then return end
        db = true
        
        -- Stop velocity loop
        if velConn then
            velConn:Disconnect()
            velConn = nil
        end
        
        -- Tween back to original position
        local tweenBack = createTween(CFrame.new(lastPos))
        tweenBack:Play()
        tweenBack.Completed:Wait()
        
        -- Reset camera and clean up
        workspace.FallenPartsDestroyHeight = -500
        resetCameraSubject()
        
        for _, gaze in ipairs(workspace:GetDescendants()) do
            if gaze:IsA("Part") and gaze.Name == "Gaze" and gaze.Transparency == 0.5 then
                workspace.Gaze:Destroy()
            end
        end
        
        db = false
    end

    if db then return end
    db = true
    
    -- Store original position
    lastPos = hrp.Position
    
    -- First teleport 20 studs underground
    local undergroundPos = Vector3.new(lastPos.X, lastPos.Y - 20, lastPos.Z)
    local undergroundTween = createTween(CFrame.new(undergroundPos))
    undergroundTween:Play()
    undergroundTween.Completed:Wait()
    
    -- Create Gaze part and set camera
    local part = Instance.new("Part")
    part.Size = Vector3.new(4, 5, 4)
    part.Position = lastPos
    part.Anchored = true
    part.CanCollide = false
    part.Transparency = 0.5
    part.Name = "Gaze"
    part.Parent = game.Workspace
    workspace.CurrentCamera.CameraSubject = part
    
    workspace.FallenPartsDestroyHeight = 0/0
    
    -- Tween to target position
    local tweenToTarget = createTween(CFrame.new(targetPos))
    tweenToTarget:Play()
    tweenToTarget.Completed:Wait()
    
    -- Start velocity loop
    startVelLoop()
    
    -- Schedule automatic stop after AutoStopTime seconds
    delay(AutoStopTime, stopScript)
    
    db = false
    return "AntiBang Executed.."
end

local LocalPlayer = Players.LocalPlayer
local TFlingActive = false
local ModeActive = false
local TFlingCoroutine
local ModeConnection

-- TFling functionality
local function TFling()
    local character = LocalPlayer.Character
    if not character then return end

    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return end

    while TFlingActive do
        RunService.Heartbeat:Wait()
        local velocity = rootPart.Velocity
        rootPart.Velocity = velocity * 999999999999999999999999999999999 + Vector3.new(0, 999999999999999999999999999999999, 0)
        RunService.RenderStepped:Wait()
        rootPart.Velocity = velocity
        RunService.Stepped:Wait()
        rootPart.Velocity = velocity + Vector3.new(0, 0.1, 0)
    end
end

-- Mode functionality
local function DisableCollisions()
    if not LocalPlayer.Character then return end
    for _, part in pairs(LocalPlayer.Character:GetDescendants()) do
        if part:IsA("BasePart") and not part.Anchored then
            part.CanCollide = false
        end
    end
end

local function EnableCollisions()
    if LocalPlayer.Character then
        for _, part in pairs(LocalPlayer.Character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = true
            end
        end
    end
end

-- Control functions
function TFlingOn()
    TFlingActive = true
    TFlingCoroutine = coroutine.create(TFling)
    coroutine.resume(TFlingCoroutine)
    return "Walkfling: TRUE"
end

function TFlingOff()
    TFlingActive = false
    if TFlingCoroutine then
        coroutine.close(TFlingCoroutine)
    end
    return "Walkfling: FALSE"
end

function ModeOn()
    ModeActive = true
    ModeConnection = RunService.Heartbeat:Connect(DisableCollisions)
    return "Noclip Enabled.."
end

function ModeOff()
    ModeActive = false
    if ModeConnection then
        ModeConnection:Disconnect()
    end
    EnableCollisions()
    return "Noclip Disabled.."
end

local function R1()

pcall(function()
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local CollectionService = game:GetService("CollectionService")
local LocalPlayer = Players.LocalPlayer
local Workspace = game:GetService("Workspace")

local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

-- Create the invisible part for attachments
local Folder = Instance.new("Folder", Workspace)
local Part = Instance.new("Part", Folder)
local Attachment1 = Instance.new("Attachment", Part)
Part.Anchored = true
Part.CanCollide = false
Part.Transparency = 1

-- GUI Implementation
local G2L = {}

-- Create ScreenGui
G2L["ScreenGui_1"] = Instance.new("ScreenGui", game:GetService("Players").LocalPlayer:WaitForChild("PlayerGui"))
G2L["ScreenGui_1"]["ZIndexBehavior"] = Enum.ZIndexBehavior.Sibling

-- Tags
CollectionService:AddTag(G2L["ScreenGui_1"], "main")

-- Main Frame
G2L["Frame_2"] = Instance.new("Frame", G2L["ScreenGui_1"])
G2L["Frame_2"]["BorderSizePixel"] = 0
G2L["Frame_2"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0)
G2L["Frame_2"]["Size"] = UDim2.new(0, 130, 0, 148)
G2L["Frame_2"]["Position"] = UDim2.new(0, 310, 0, 60)
G2L["Frame_2"]["BackgroundTransparency"] = 0.2

-- Radius TextBox
G2L["RaidusTextBox_3"] = Instance.new("TextBox", G2L["Frame_2"])
G2L["RaidusTextBox_3"]["CursorPosition"] = -1
G2L["RaidusTextBox_3"]["Name"] = "RaidusTextBox"
G2L["RaidusTextBox_3"]["BorderSizePixel"] = 0
G2L["RaidusTextBox_3"]["TextColor3"] = Color3.fromRGB(0, 255, 0)
G2L["RaidusTextBox_3"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0)
G2L["RaidusTextBox_3"]["PlaceholderText"] = "Radius"
G2L["RaidusTextBox_3"]["Size"] = UDim2.new(0, 100, 0, 20)
G2L["RaidusTextBox_3"]["Position"] = UDim2.new(0, 16, 0, 62)
G2L["RaidusTextBox_3"]["Text"] = "70"
G2L["RaidusTextBox_3"]["TextSize"] = 14
G2L["RaidusTextBox_3"]["Font"] = Enum.Font.Arcade


-- Radius TextBox Corner
G2L["UICorner_4"] = Instance.new("UICorner", G2L["RaidusTextBox_3"])

-- Main Frame Corner
G2L["UICorner_5"] = Instance.new("UICorner", G2L["Frame_2"])

-- Frame for minimize button
G2L["Frame2_6"] = Instance.new("Frame", G2L["Frame_2"])
G2L["Frame2_6"]["BorderSizePixel"] = 0
G2L["Frame2_6"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0)
G2L["Frame2_6"]["Size"] = UDim2.new(0, 130, 0, 20)
G2L["Frame2_6"]["Name"] = "Frame2"

-- Frame2 Corner
G2L["UICorner_7"] = Instance.new("UICorner", G2L["Frame2_6"])

-- Minimize Button
G2L["MinimiseBtn_8"] = Instance.new("TextButton", G2L["Frame2_6"])
G2L["MinimiseBtn_8"]["BorderSizePixel"] = 0
G2L["MinimiseBtn_8"]["TextSize"] = 11
G2L["MinimiseBtn_8"]["BackgroundColor3"] = Color3.fromRGB(0, 255, 0)
G2L["MinimiseBtn_8"]["BackgroundTransparency"] = 1
G2L["MinimiseBtn_8"]["Size"] = UDim2.new(0, 32, 0, 18)
G2L["MinimiseBtn_8"]["Text"] = ""
G2L["MinimiseBtn_8"]["Name"] = "MinimiseBtn"
G2L["MinimiseBtn_8"]["Position"] = UDim2.new(0, 98, 0, 0)

-- Attraction Strength TextBox
G2L["ASTextBox_9"] = Instance.new("TextBox", G2L["Frame_2"])
G2L["ASTextBox_9"]["CursorPosition"] = -1
G2L["ASTextBox_9"]["Name"] = "ASTextBox"
G2L["ASTextBox_9"]["BorderSizePixel"] = 0
G2L["ASTextBox_9"]["TextColor3"] = Color3.fromRGB(0, 255, 0)
G2L["ASTextBox_9"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0)
G2L["ASTextBox_9"]["PlaceholderText"] = "Speed"
G2L["ASTextBox_9"]["Size"] = UDim2.new(0, 100, 0, 20)
G2L["ASTextBox_9"]["Position"] = UDim2.new(0, 16, 0, 86)
G2L["ASTextBox_9"]["Text"] = "555"
G2L["ASTextBox_9"]["TextSize"] = 14
G2L["ASTextBox_9"]["Font"] = Enum.Font.Arcade


-- AS TextBox Corner
G2L["UICorner_a"] = Instance.new("UICorner", G2L["ASTextBox_9"])

-- Toggle Button
G2L["Toggle_b"] = Instance.new("TextButton", G2L["Frame_2"])
G2L["Toggle_b"]["BorderSizePixel"] = 0
G2L["Toggle_b"]["TextColor3"] = Color3.fromRGB(0, 255, 0)
G2L["Toggle_b"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0)
G2L["Toggle_b"]["Size"] = UDim2.new(0, 104, 0, 24)
G2L["Toggle_b"]["Text"] = "Ringparts: OFF"
G2L["Toggle_b"]["Name"] = "Toggle"
G2L["Toggle_b"]["Position"] = UDim2.new(0, 14, 0, 30)
G2L["Toggle_b"]["TextSize"] = 12
G2L["Toggle_b"]["Font"] = Enum.Font.Arcade

-- Toggle Button Corner
G2L["UICorner_c"] = Instance.new("UICorner", G2L["Toggle_b"])

-- Title
G2L["Title_d"] = Instance.new("TextLabel", G2L["Frame_2"])
G2L["Title_d"]["BorderSizePixel"] = 0
G2L["Title_d"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0)
G2L["Title_d"]["TextColor3"] = Color3.fromRGB(0, 255, 0)
G2L["Title_d"]["BackgroundTransparency"] = 1
G2L["Title_d"]["Size"] = UDim2.new(0, 88, 0, 12)
G2L["Title_d"]["Text"] = "RingParts"
G2L["Title_d"]["Name"] = "Title"
G2L["Title_d"]["Position"] = UDim2.new(0, 20, 0, 4)
G2L["Title_d"]["TextSize"] = 14
G2L["Title_d"]["Font"] = Enum.Font.Arcade


-- UI Stroke
G2L["UIStroke_e"] = Instance.new("UIStroke", G2L["Frame_2"])
G2L["UIStroke_e"]["Transparency"] = 0.1
G2L["UIStroke_e"]["Thickness"] = 3
G2L["UIStroke_e"]["Color"] = Color3.fromRGB(0, 0, 0)

-- SuperRing functionality
local radius = tonumber(G2L["RaidusTextBox_3"].Text) or 70
local height = 100
local rotationSpeed = 0.5
local attractionStrength = tonumber(G2L["ASTextBox_9"].Text) or 555
local ringPartsEnabled = false

-- Network part control
if not getgenv().Network then
    getgenv().Network = {
        BaseParts = {},
        Velocity = Vector3.new(14.46262424, 14.46262424, 14.46262424)
    }

    Network.RetainPart = function(Part)
        if typeof(Part) == "Instance" and Part:IsA("BasePart") and Part:IsDescendantOf(Workspace) then
            table.insert(Network.BaseParts, Part)
            Part.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
            Part.CanCollide = false
        end
    end

    local function EnablePartControl()
        LocalPlayer.ReplicationFocus = Workspace
        RunService.Heartbeat:Connect(function()
            sethiddenproperty(LocalPlayer, "SimulationRadius", math.huge)
            for _, Part in pairs(Network.BaseParts) do
                if Part:IsDescendantOf(Workspace) then
                    Part.Velocity = Network.Velocity
                end
            end
        end)
    end

    EnablePartControl()
end

local function ForcePart(v)
    if v:IsA("Part") and not v.Anchored and not v.Parent:FindFirstChild("Humanoid") and not v.Parent:FindFirstChild("Head") and v.Name ~= "Handle" then
        for _, x in next, v:GetChildren() do
            if x:IsA("BodyAngularVelocity") or x:IsA("BodyForce") or x:IsA("BodyGyro") or x:IsA("BodyPosition") or x:IsA("BodyThrust") or x:IsA("BodyVelocity") or x:IsA("RocketPropulsion") then
                x:Destroy()
            end
        end
        if v:FindFirstChild("Attachment") then
            v:FindFirstChild("Attachment"):Destroy()
        end
        if v:FindFirstChild("AlignPosition") then
            v:FindFirstChild("AlignPosition"):Destroy()
        end
        if v:FindFirstChild("Torque") then
            v:FindFirstChild("Torque"):Destroy()
        end
        v.CanCollide = false
        local Torque = Instance.new("Torque", v)
        Torque.Torque = Vector3.new(100000, 100000, 100000)
        local AlignPosition = Instance.new("AlignPosition", v)
        local Attachment2 = Instance.new("Attachment", v)
        Torque.Attachment0 = Attachment2
        AlignPosition.MaxForce = 9999999999999999
        AlignPosition.MaxVelocity = math.huge
        AlignPosition.Responsiveness = 200
        AlignPosition.Attachment0 = Attachment2
        AlignPosition.Attachment1 = Attachment1
    end
end

local function RetainPart(Part)
    if Part:IsA("BasePart") and not Part.Anchored and Part:IsDescendantOf(workspace) then
        if Part.Parent == LocalPlayer.Character or Part:IsDescendantOf(LocalPlayer.Character) then
            return false
        end

        Part.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
        Part.CanCollide = false
        return true
    end
    return false
end

local parts = {}
local function addPart(part)
    if RetainPart(part) then
        if not table.find(parts, part) then
            table.insert(parts, part)
        end
    end
end

local function removePart(part)
    local index = table.find(parts, part)
    if index then
        table.remove(parts, index)
    end
end

for _, part in pairs(workspace:GetDescendants()) do
    addPart(part)
end

workspace.DescendantAdded:Connect(addPart)
workspace.DescendantRemoving:Connect(removePart)

RunService.Heartbeat:Connect(function()
    if not ringPartsEnabled then return end
    
    local humanoidRootPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if humanoidRootPart then
        local tornadoCenter = humanoidRootPart.Position
        for _, part in pairs(parts) do
            if part.Parent and not part.Anchored then
                local pos = part.Position
                local distance = (Vector3.new(pos.X, tornadoCenter.Y, pos.Z) - tornadoCenter).Magnitude
                local angle = math.atan2(pos.Z - tornadoCenter.Z, pos.X - tornadoCenter.X)
                local newAngle = angle + math.rad(rotationSpeed)
                local targetPos = Vector3.new(
                    tornadoCenter.X + math.cos(newAngle) * math.min(radius, distance),
                    tornadoCenter.Y + (height * (math.abs(math.sin((pos.Y - tornadoCenter.Y) / height)))),
                    tornadoCenter.Z + math.sin(newAngle) * math.min(radius, distance)
                )
                local directionToTarget = (targetPos - part.Position).unit
                part.Velocity = directionToTarget * attractionStrength
            end
        end
    end
end)

-- Button functionality
G2L["Toggle_b"].MouseButton1Click:Connect(function()
    ringPartsEnabled = not ringPartsEnabled
    G2L["Toggle_b"].Text = ringPartsEnabled and "Ringparts: ON" or "Ringparts: OFF"
end)

-- Update radius when text changes
G2L["RaidusTextBox_3"].FocusLost:Connect(function(enterPressed)
    if enterPressed then
        local newRadius = tonumber(G2L["RaidusTextBox_3"].Text)
        if newRadius then
            radius = math.clamp(newRadius, 1, 1000)
            G2L["RaidusTextBox_3"].Text = tostring(radius)
        else
            G2L["RaidusTextBox_3"].Text = tostring(radius)
        end
    end
end)

-- Update attraction strength when text changes
G2L["ASTextBox_9"].FocusLost:Connect(function(enterPressed)
    if enterPressed then
        local newStrength = tonumber(G2L["ASTextBox_9"].Text)
        if newStrength then
            attractionStrength = math.clamp(newStrength, 1, 10000)
            G2L["ASTextBox_9"].Text = tostring(attractionStrength)
        else
            G2L["ASTextBox_9"].Text = tostring(attractionStrength)
        end
    end
end)

-- Make GUI draggable
local dragging
local dragInput
local dragStart
local startPos

local function update(input)
    local delta = input.Position - dragStart
    G2L["Frame_2"].Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
end

G2L["Frame_2"].InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = G2L["Frame_2"].Position
        
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

G2L["Frame_2"].InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
        dragInput = input
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if input == dragInput and dragging then
        update(input)
    end
end)

-- Minimize functionality
local minimized = false
G2L["MinimiseBtn_8"].MouseButton1Click:Connect(function()
    minimized = not minimized
    if minimized then
        G2L["Frame_2"].Size = UDim2.new(0, 130, 0, 20)
        G2L["Toggle_b"].Visible = false
        G2L["RaidusTextBox_3"].Visible = false
        G2L["ASTextBox_9"].Visible = false
        G2L["MinimiseBtn_8"].Text = ""
    else
        G2L["Frame_2"].Size = UDim2.new(0, 130, 0, 148)
        G2L["Toggle_b"].Visible = true
        G2L["RaidusTextBox_3"].Visible = true
        G2L["ASTextBox_9"].Visible = true
        G2L["MinimiseBtn_8"].Text = ""
    end
end)
end)
return "RingParts Loaded.."
end

local VirtualUser = game:GetService('VirtualUser')
local antiAFKConnection = nil

function antiafkon()
    if antiAFKConnection then
        antiAFKConnection:Disconnect()
    end
    antiAFKConnection = game:GetService('Players').LocalPlayer.Idled:Connect(function()
        VirtualUser:CaptureController()
        VirtualUser:ClickButton2(Vector2.new())
    end)
    return "Anti-AFK enabled"
end

function antiafkoff()
    if antiAFKConnection then
        antiAFKConnection:Disconnect()
        antiAFKConnection = nil
        return "Anti-AFK disabled"
    else
        showNotification("Anti-AFK wasn't enabled!", true)
    end
end

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local speaker = Players.LocalPlayer

local antiflingConnection = nil

function Afon()
    if antiflingConnection then
        antiflingConnection:Disconnect()
    end

    antiflingConnection = RunService.Stepped:Connect(function()
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= speaker and player.Character then
                for _, v in pairs(player.Character:GetDescendants()) do
                    if v:IsA("BasePart") then
                        v.CanCollide = false
                    end
                end
            end
        end
    end)
    return "Anti-Fling enabled" 
end

function Afoff()
    if antiflingConnection then
        antiflingConnection:Disconnect()
        antiflingConnection = nil
    end
    return "Anti-Fling disabled" 
end

local player = game.Players.LocalPlayer
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")

-- Physics Settings
local GRAVITY_MULTIPLIER = 1.5 -- Visible but not too fast
local INITIAL_BOOST = 10 -- Gentle push to start
local MAX_SPEED = 20 -- Maximum upward speed
local SIMULATION_RADIUS = 5000 -- Large area of effect

-- System Variables
local invertedParts = {}
local connection = nil
local heartbeatConnection = nil

local function cleanUpForces(part)
    for _, child in ipairs(part:GetChildren()) do
        if child:IsA("BodyForce") or child:IsA("BodyVelocity") then
            child:Destroy()
        end
    end
end

local function applyUpwardForce()
    -- Ensure we can affect distant parts
    sethiddenproperty(player, "SimulationRadius", SIMULATION_RADIUS)
    sethiddenproperty(player, "MaxSimulationRadius", SIMULATION_RADIUS)
    
    for part, data in pairs(invertedParts) do
        if part and part.Parent then
            -- Calculate upward force based on part's mass
            local force = part:GetMass() * Workspace.Gravity * GRAVITY_MULTIPLIER
            
            -- Apply force while respecting max speed
            if part.Velocity.Y < MAX_SPEED then
                part:ApplyImpulse(Vector3.new(0, force * 0.016, 0)) -- 0.016  1/60 for frame independence
            end
            
            -- Ensure parts don't get stuck
            if part.Velocity.Y < 5 then
                part.Velocity = Vector3.new(0, 5, 0)
            end
        else
            invertedParts[part] = nil
        end
    end
end

local function invertGravity(part)
    if part:IsA("BasePart") and not part.Anchored and not part:IsDescendantOf(player.Character) then
        if not invertedParts[part] then
            -- Store original state
            invertedParts[part] = {
                CanCollide = part.CanCollide,
                CustomPhysicalProperties = part.CustomPhysicalProperties
            }
            
            -- Clean existing forces
            cleanUpForces(part)
            
            -- Configure part physics
            part.CanCollide = false
            part.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
            
            -- Initial gentle push
            part.Velocity = Vector3.new(0, INITIAL_BOOST, 0)
            
            -- Add permanent upward force
            local bodyForce = Instance.new("BodyForce")
            bodyForce.Force = Vector3.new(0, part:GetMass() * Workspace.Gravity * GRAVITY_MULTIPLIER, 0)
            bodyForce.Parent = part
            invertedParts[part].bodyForce = bodyForce
        end
    end
end

local function restoreGravity(part)
    if invertedParts[part] then
        cleanUpForces(part)
        part.CanCollide = invertedParts[part].CanCollide
        part.CustomPhysicalProperties = invertedParts[part].CustomPhysicalProperties
        part.Velocity = Vector3.new(0, 0, 0)
        invertedParts[part] = nil
    end
end

function GravOn()
    -- Set physics range
    sethiddenproperty(player, "SimulationRadius", SIMULATION_RADIUS)
    
    -- Process existing parts
    for _, part in ipairs(Workspace:GetDescendants()) do
        invertGravity(part)
    end
    
    -- Continuous force application
    if heartbeatConnection then heartbeatConnection:Disconnect() end
    heartbeatConnection = RunService.Heartbeat:Connect(applyUpwardForce)
    
    -- Detect new parts
    if connection then connection:Disconnect() end
    connection = Workspace.DescendantAdded:Connect(invertGravity)
    return "Gravity Invert enabled"
end

function GravOff()
    -- Clean up
    if heartbeatConnection then
        heartbeatConnection:Disconnect()
        heartbeatConnection = nil
    end
    
    for part in pairs(invertedParts) do
        if part.Parent then
            restoreGravity(part)
        end
    end
    
    invertedParts = {}
    if connection then
        connection:Disconnect()
        connection = nil
    end
    return "Gravity Invert disabled"
end

local function CreateTptool()
    local players = game:GetService("Players")
    local localPlayer = players.LocalPlayer
    local backpack = localPlayer.Backpack
    local mouse = localPlayer:GetMouse()
    
    local function isAlive(Player, headCheck)
        local Player = Player or localPlayer
        if Player and Player.Character and ((Player.Character:FindFirstChildOfClass("Humanoid")) and (Player.Character:FindFirstChild("HumanoidRootPart")) and (headCheck and Player.Character:FindFirstChild("Head") or not headCheck)) then
            return true
        else
            return false
        end
    end
    
    local tool = Instance.new("Tool")
    tool.Name = "TPTool"
    tool.Parent = backpack
    tool.RequiresHandle = false
    tool.Activated:Connect(function()
    	if isAlive() then
    		localPlayer.Character.HumanoidRootPart.CFrame = mouse.Hit + Vector3.new(0, 3, 0)
    	end
    end)
    return "Created TpTool.."
    end

local function DexExe()
    loadstring(game:HttpGet("https://raw.githubusercontent.com/infyiff/backup/main/dex.lua"))()
    return "Dex Loaded.."
end

-- Black Hole Script Function
local function blackHoleScript()
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local LocalPlayer = Players.LocalPlayer
    local Workspace = game:GetService("Workspace")

    local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

    Folder = Instance.new("Folder", Workspace)
    local Part = Instance.new("Part", Folder)
    Attachment1 = Instance.new("Attachment", Part)
    Part.Anchored = true
    Part.CanCollide = false
    Part.Transparency = 1

    if not Network then
        Network = {
            BaseParts = {},
            Velocity = Vector3.new(14.46262424, 14.46262424, 14.46262424)
        }

        Network.RetainPart = function(Part)
            if typeof(Part) == "Instance" and Part:IsA("BasePart") and Part:IsDescendantOf(Workspace) then
                table.insert(Network.BaseParts, Part)
                Part.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
                Part.CanCollide = false
            end
        end

        local function EnablePartControl()
            LocalPlayer.ReplicationFocus = Workspace
            RunService.Heartbeat:Connect(function()
                sethiddenproperty(LocalPlayer, "SimulationRadius", math.huge)
                for _, Part in pairs(Network.BaseParts) do
                    if Part:IsDescendantOf(Workspace) then
                        Part.Velocity = Network.Velocity
                    end
                end
            end)
        end

        EnablePartControl()
    end

    local function ForcePart(v)
        if v:IsA("Part") and not v.Anchored and not v.Parent:FindFirstChild("Humanoid") and not v.Parent:FindFirstChild("Head") and v.Name ~= "Handle" then
            for _, x in next, v:GetChildren() do
                if x:IsA("BodyAngularVelocity") or x:IsA("BodyForce") or x:IsA("BodyGyro") or x:IsA("BodyPosition") or x:IsA("BodyThrust") or x:IsA("BodyVelocity") or x:IsA("RocketPropulsion") then
                    x:Destroy()
                end
            end
            if v:FindFirstChild("Attachment") then
                v:FindFirstChild("Attachment"):Destroy()
            end
            if v:FindFirstChild("AlignPosition") then
                v:FindFirstChild("AlignPosition"):Destroy()
            end
            if v:FindFirstChild("Torque") then
                v:FindFirstChild("Torque"):Destroy()
            end
            v.CanCollide = false
            local Torque = Instance.new("Torque", v)
            Torque.Torque = Vector3.new(100000, 100000, 100000)
            local AlignPosition = Instance.new("AlignPosition", v)
            local Attachment2 = Instance.new("Attachment", v)
            Torque.Attachment0 = Attachment2
            AlignPosition.MaxForce = 9999999999999999
            AlignPosition.MaxVelocity = math.huge
            AlignPosition.Responsiveness = 200
            AlignPosition.Attachment0 = Attachment2
            AlignPosition.Attachment1 = Attachment1
        end
    end

    blackHoleActive = true

    for _, v in next, Workspace:GetDescendants() do
        ForcePart(v)
    end

    Workspace.DescendantAdded:Connect(function(v)
        if blackHoleActive then
            ForcePart(v)
        end
    end)

    spawn(function()
        while blackHoleActive and RunService.RenderStepped:Wait() do
            Attachment1.WorldCFrame = humanoidRootPart.CFrame
        end
    end)
    return "BlackHole: TRUE"
end

-- Function to disable black hole
local function disableBlackHole()
    blackHoleActive = false
    if Folder then
        Folder:Destroy()
        Folder = nil
    end
    if Network then
        Network.BaseParts = {}
    end
    return "BlackHole: FALSE"
end

local function tk()
    loadstring(game:HttpGet("https://raw.githubusercontent.com/hm5650/Control-part/refs/heads/main/CP"))()
    return "Telekinesis Loaded.."
end

-- Commands with aliases
AddCommandWithValue("walkspeed", "speed", "ws", "Sets your speed (16 Default)", function(speed)
    speed = tonumber(speed)
    if not speed then
        showNotification("Invalid speed!", true)
    end

    local character = game.Players.LocalPlayer.Character
    if character and character:FindFirstChildOfClass("Humanoid") then
        character:FindFirstChildOfClass("Humanoid").WalkSpeed = speed
        return "WalkSpeed set to\n" .. speed
    else
        return "Character or Humanoid not found."
    end
end)

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

local tpwalking = false
local speeds = 1

local function getCharacter()
    local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local humanoid = character:WaitForChild("Humanoid")
    local rootPart = character:WaitForChild("HumanoidRootPart")
    return character, humanoid, rootPart
end

local function TpWalk()
    local _, humanoid, rootPart = getCharacter()
    tpwalking = true

    while tpwalking and humanoid.Health > 0 do
        RunService.Heartbeat:Wait()

        if humanoid.MoveDirection.Magnitude > 0 then
            local moveDirection = humanoid.MoveDirection.Unit
            local velocity = moveDirection * speeds * 50
            rootPart.CFrame = rootPart.CFrame + velocity * RunService.Heartbeat:Wait()
        end
    end
end

-- Command: tpwalk <value>
AddCommandWithValue("tpwalk", "speed", "tpw", "More safer walkspeed", function(speed)
    speed = tonumber(speed)
    if not speed then
        showNotification("Invalid speed!", true)
    end

    speeds = speed
    if not tpwalking then
        task.spawn(TpWalk)
    end
    return "Tpwalk set to\n" .. speeds
end)

-- Command: stoptpwalk
AddCommand("stoptpwalk", "untpw", "Stops Tpwalk", function()
    tpwalking = false
    return "Tpwalk stopped."
end)

local function rag()
    loadstring(game:HttpGet('https://raw.githubusercontent.com/shakk-code/fe-ragdoll-script/refs/heads/main/script.lua', true))()
    return "Ragdoll Tool Executed.."
end

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local loopaatConnection = nil

function loopaat2()
	if loopaatConnection then return end -- already looping

	loopaatConnection = RunService.Heartbeat:Connect(function()
		local backpack = player:FindFirstChildOfClass("Backpack")
		local character = player.Character
		if not backpack or not character then return end

		local tools = {}
		for _, item in ipairs(backpack:GetChildren()) do
			if item:IsA("Tool") then
				table.insert(tools, item)
			end
		end

		if #tools > 0 then
			local randomTool = tools[math.random(1, #tools)]
			randomTool.Parent = character
			task.wait(0.005)
			pcall(function()
				randomTool:Activate()
			end)
			task.wait(0.005)
			randomTool.Parent = backpack
		end
	end)
   return "LoopAAT Enabled"
end

function unloopaat1()
	if loopaatConnection then
		loopaatConnection:Disconnect()
		loopaatConnection = nil
	end
   return "LoopAAT Disabled"
end

-- Fling command system
local Players = game:GetService("Players")
local Player = Players.LocalPlayer
local RunService = game:GetService("RunService")

local function GetPlayer(Name)
    Name = Name:lower()
    for _, x in next, Players:GetPlayers() do
        if x ~= Player then
            if x.Name:lower():match("^" .. Name) or x.DisplayName:lower():match("^" .. Name) then
                return x
            end
        end
    end
    return nil
end

local function SkidFling(TargetPlayer)
    local Character = Player.Character
    local Humanoid = Character and Character:FindFirstChildOfClass("Humanoid")
    local RootPart = Humanoid and Humanoid.RootPart

    local TCharacter = TargetPlayer.Character
    local THumanoid = TCharacter and TCharacter:FindFirstChildOfClass("Humanoid")
    local TRootPart = THumanoid and THumanoid.RootPart
    local THead = TCharacter and TCharacter:FindFirstChild("Head")
    local Accessory = TCharacter and TCharacter:FindFirstChildOfClass("Accessory")
    local Handle = Accessory and Accessory:FindFirstChild("Handle")

    if not Character or not Humanoid or not RootPart then
        showNotification("Character not found!", true)
    end

    if not TCharacter or not THumanoid then
        showNotification("Target not found!", true)
    end

    if THumanoid.Sit then
        showNotification("Target Is Sitting!", true)
    end

    -- Save original position
    local OldPos = RootPart.CFrame
    local OldFPDH = workspace.FallenPartsDestroyHeight
    workspace.FallenPartsDestroyHeight = 0/0

    -- Set camera subject
    if THead then
        workspace.CurrentCamera.CameraSubject = THead
    elseif Handle then
        workspace.CurrentCamera.CameraSubject = Handle
    else
        workspace.CurrentCamera.CameraSubject = THumanoid
    end

    -- Create velocity
    local BV = Instance.new("BodyVelocity")
    BV.Name = "EpixVel"
    BV.Parent = RootPart
    BV.Velocity = Vector3.new(9e8, 9e8, 9e8)
    BV.MaxForce = Vector3.new(1/0, 1/0, 1/0)

    Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)

    local function FPos(BasePart, Pos, Ang)
        RootPart.CFrame = CFrame.new(BasePart.Position) * Pos * Ang
        Character:SetPrimaryPartCFrame(CFrame.new(BasePart.Position) * Pos * Ang)
        RootPart.Velocity = Vector3.new(9e7, 9e7 * 10, 9e7)
        RootPart.RotVelocity = Vector3.new(9e8, 9e8, 9e8)
    end

    local function SFBasePart(BasePart)
        local TimeToWait = 2
        local Time = tick()
        local Angle = 0

        repeat
            if RootPart and THumanoid then
                if BasePart.Velocity.Magnitude < 50 then
                    Angle = Angle + 100

                    FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle),0 ,0))
                    task.wait()

                    FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                    task.wait()

                    FPos(BasePart, CFrame.new(2.25, 1.5, -2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                    task.wait()

                    FPos(BasePart, CFrame.new(-2.25, -1.5, 2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                    task.wait()

                    FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection,CFrame.Angles(math.rad(Angle), 0, 0))
                    task.wait()

                    FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection,CFrame.Angles(math.rad(Angle), 0, 0))
                    task.wait()
                else
                    FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0))
                    task.wait()

                    FPos(BasePart, CFrame.new(0, -1.5, -THumanoid.WalkSpeed), CFrame.Angles(0, 0, 0))
                    task.wait()

                    FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0))
                    task.wait()
                        
                    FPos(BasePart, CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(math.rad(90), 0, 0))
                    task.wait()

                    FPos(BasePart, CFrame.new(0, -1.5, -TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(0, 0, 0))
                    task.wait()

                    FPos(BasePart, CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(math.rad(90), 0, 0))
                    task.wait()

                    FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(math.rad(90), 0, 0))
                    task.wait()

                    FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(0, 0, 0))
                    task.wait()

                    FPos(BasePart, CFrame.new(0, -1.5 ,0), CFrame.Angles(math.rad(-90), 0, 0))
                    task.wait()

                    FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(0, 0, 0))
                    task.wait()
                end
            else
                break
            end
        until BasePart.Velocity.Magnitude > 500 or BasePart.Parent ~= TargetPlayer.Character or TargetPlayer.Parent ~= Players or not TargetPlayer.Character == TCharacter or THumanoid.Sit or Humanoid.Health <= 0 or tick() > Time + TimeToWait
    end

    -- Choose which part to fling
    if TRootPart and THead then
        if (TRootPart.CFrame.p - THead.CFrame.p).Magnitude > 5 then
            SFBasePart(THead)
        else
            SFBasePart(TRootPart)
        end
    elseif TRootPart and not THead then
        SFBasePart(TRootPart)
    elseif not TRootPart and THead then
        SFBasePart(THead)
    elseif not TRootPart and not THead and Accessory and Handle then
        SFBasePart(Handle)
    else
        BV:Destroy()
        workspace.FallenPartsDestroyHeight = OldFPDH
        return "Target is missing everything"
    end

    -- Clean up
    BV:Destroy()
    Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
    workspace.CurrentCamera.CameraSubject = Humanoid

    -- Return to original position
    repeat
        RootPart.CFrame = OldPos * CFrame.new(0, .5, 0)
        Character:SetPrimaryPartCFrame(OldPos * CFrame.new(0, .5, 0))
        Humanoid:ChangeState("GettingUp")
        for _, x in ipairs(Character:GetChildren()) do
            if x:IsA("BasePart") then
                x.Velocity, x.RotVelocity = Vector3.new(), Vector3.new()
            end
        end
        task.wait()
    until (RootPart.Position - OldPos.p).Magnitude < 25
    
    workspace.FallenPartsDestroyHeight = OldFPDH
    return "Flinged " .. TargetPlayer.Name
end

local function credits()
    return "Script Made By\nhmmm5650.."
end

local function cmdl()
    loadstring(game:HttpGet("https://raw.githubusercontent.com/hm5650/O/refs/heads/main/O", true))()
    return "CmdLooper Loaded.."
end

local function fexpanel()
    loadstring(game:HttpGet("https://raw.githubusercontent.com/SkireScripts/F3X-Panel/main/Main.lua"))()
    return "F3XPanel Loaded.."
end

local function tc()
    loadstring(game:HttpGet("https://raw.githubusercontent.com/v0c0n1337/scripts/refs/heads/main/FE%20Tool%20control.txt"))()
    return "Executed ToolControl\n Hold A Tool!"
end

local function Vcban()
    game:GetService("VoiceChatService"):joinVoice()
    return "Removed VCBan.."
end

local function re()
    game.Players.LocalPlayer.Character.Head:Destroy()
    return "Resetting Character.."
end

local function fex()
    loadstring(game:GetObjects("rbxassetid://6695644299")[1].Source)()
    return "Gear Found!..\n6695644299"
end

local function partm()
    loadstring(game:HttpGet("https://pastefy.app/Vcuyg09O/raw", true))()
    return "PartMover Executed.."
end

-- This code should be in a LocalScript in Roblox
local Players = game:GetService("Players")
local player = Players.LocalPlayer

local function sit()
    local character = player.Character
    if character and character:FindFirstChild("Humanoid") then
        character.Humanoid.Sit = true
        return "Sitting.."
    else
        showNotification("Failed to sit!", true)
    end
end

local function DAT()
    -- Get the player's character and backpack
    local player = game:GetService("Players").LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    local backpack = player:FindFirstChild("Backpack")
    
    if not backpack then
        showNotification("Backpack not found!", true)
        return
    end
    
    -- Get all tools in the backpack
    local tools = {}
    for _, item in ipairs(backpack:GetChildren()) do
        if item:IsA("Tool") then
            table.insert(tools, item)
        end
    end
    
    -- Drop each tool
    for _, tool in ipairs(tools) do
        -- Equip the tool first (necessary to drop it)
        tool.Parent = character
        task.wait(0.1) -- Small delay to ensure tool is equipped
        
        -- Drop the tool
        tool.Parent = workspace
        tool:FindFirstChild("Handle").Anchored = false -- Ensure it can fall
    end
    
    return "Dropped:\n" .. #tools .. " tools"
end

-- VoidProtection Variable
local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
local voidYLevel = -100 -- Adjust based on your game's void height
local protectionEnabled = false
local bounceForce = 10000   -- Initial upward force
local maxBounceForce = 999e999
local platformCheckRaycast = 5 -- Raycast distance to check for platforms below
local inVoid = false -- Track if player is in void

local function checkPlatformBelow()
    if not humanoidRootPart then return false end
    
    local rayOrigin = humanoidRootPart.Position
    local rayDirection = Vector3.new(0, -platformCheckRaycast, 0)
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {character}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    
    local raycastResult = workspace:Raycast(rayOrigin, rayDirection, raycastParams)
    return raycastResult and raycastResult.Instance
end

local function applyBounce()
    if not humanoidRootPart or not protectionEnabled then return end
    
    -- Apply upward velocity (like a bounce)
    humanoidRootPart.AssemblyLinearVelocity = Vector3.new(0, bounceForce, 0)
    
    -- Increase bounce force for next time (capped at maxBounceForce)
    bounceForce = math.min(bounceForce + 100, maxBounceForce)
    
    print("Bouncing with force:", bounceForce) -- Debug output
end

local function checkVoidPosition()
    while protectionEnabled and humanoidRootPart do
        local isInVoidNow = humanoidRootPart.Position.Y < voidYLevel
        
        -- Check for platform below regardless of void state
        local onPlatform = checkPlatformBelow()
        
        if onPlatform then
            -- Player landed on something, reset bounce force
            bounceForce = 100
            inVoid = false
        elseif isInVoidNow then
            -- Player is in void, apply bounce
            if not inVoid then
                -- First time entering void
                bounceForce = 100
                inVoid = true
            else
                -- Continuous bouncing in void
                applyBounce()
            end
        else
            inVoid = false
        end
        
        task.wait(0.1) -- More efficient than wait()
    end
end

function VoidProtectionOn()
    if not protectionEnabled then
        protectionEnabled = true
        inVoid = false
        bounceForce = 100 -- Reset force when turning on
        checkVoidPosition()
        return "Void Protection: ON"
    end
end

function VoidProtectionOff()
    protectionEnabled = false
    return "Void Protection: OFF"
end

local function kfw()
    loadstring(game:HttpGet("https://raw.githubusercontent.com/hm5650/Killerfish/refs/heads/main/KFW", true))()
    return "Numero Loaded.."
end

local function PCR()
loadstring(game:HttpGet("https://raw.githubusercontent.com/hm5650/PartController/refs/heads/main/PartController.lua", true))()
return "PC Loaded.."
end

local function tornado()
loadstring(game:HttpGet("https://raw.githubusercontent.com/hm5650/TornadoGuiIg/refs/heads/main/Srrylolitsobfuscatednomorestealing", true))()
return "TornadoGui Loaded.."
end

local function al11()
loadstring(game:HttpGet("https://raw.githubusercontent.com/igfrx/tpmorPpoT/refs/heads/main/aL", true))()
return "Optimized!.."
end

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

-- Variables
local LocalPlayer = Players.LocalPlayer
local PartsFolder = Instance.new("Folder")
PartsFolder.Parent = Workspace
PartsFolder.Name = "TopPrompt"

-- Global handler reference for stopping
local handler = nil

-- Bypass System
local function InitializeBypass()
    local mt = getrawmetatable(game)
    setreadonly(mt, false)
    local old = mt.__namecall
    mt.__namecall = newcclosure(function(self, ...)
        local args = {...}
        local method = getnamecallmethod()
        if method == "FireServer" then
            return nil
        end
        return old(self, ...)
    end)
    
    for _, v in next, getconnections(game:GetService("ScriptContext").Error) do 
        v:Disable()
    end
    
    for _, v in next, getconnections(game:GetService("LogService").MessageOut) do 
        v:Disable()
    end
end

-- Network Ownership
local function SetupNetwork()
    settings().Physics.AllowSleep = false
    settings().Physics.PhysicsEnvironmentalThrottle = Enum.EnviromentalPhysicsThrottle.Disabled
    
    if not getgenv().NetworkBypass then
        getgenv().NetworkBypass = true
        local old
        old = hookmetamethod(game, "__index", newcclosure(function(self, idx)
            if idx == "NetworkOwnershipRule" then
                return Enum.NetworkOwnership.Manual
            end
            return old(self, idx)
        end))
    end
end

-- Main Destroyer System
local BasePartHandler = {}
BasePartHandler.__index = BasePartHandler

function BasePartHandler.new()
    local self = setmetatable({}, BasePartHandler)
    self.Connections = {}
    self.TargetParts = {}
    return self
end

function BasePartHandler:SetupPart(part)
    if part:IsA("BasePart") and not part.Anchored then
        if not part:IsDescendantOf(LocalPlayer.Character) then
            -- Setup part physics
            part.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
            
            -- Create constraints
            local attachment = Instance.new("Attachment")
            attachment.Parent = part
            
            local alignPosition = Instance.new("AlignPosition")
            alignPosition.Mode = Enum.PositionAlignmentMode.OneAttachment
            alignPosition.Attachment0 = attachment
            alignPosition.MaxForce = 999999999999999
            alignPosition.MaxVelocity = math.huge
            alignPosition.Responsiveness = 200
            alignPosition.Parent = part
            
            local gyro = Instance.new("BodyGyro")
            gyro.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
            gyro.P = 100000
            gyro.Parent = part
            
            -- Add to control list
            table.insert(self.TargetParts, {
                Part = part,
                Attachment = attachment,
                AlignPosition = alignPosition,
                Gyro = gyro
            })
        end
    end
end

function BasePartHandler:Start()
    -- Setup all existing parts
    for _, v in ipairs(Workspace:GetDescendants()) do
        self:SetupPart(v)
    end
    
    -- Monitor new parts
    table.insert(self.Connections, Workspace.DescendantAdded:Connect(function(v)
        self:SetupPart(v)
    end))
    
    -- Main control loop
    table.insert(self.Connections, RunService.Heartbeat:Connect(function()
        sethiddenproperty(LocalPlayer, "SimulationRadius", math.huge)
        sethiddenproperty(LocalPlayer, "MaxSimulationRadius", math.huge)
        
        for _, targetData in ipairs(self.TargetParts) do
            pcall(function()
                local part = targetData.Part
                if part and part.Parent then
                    -- Get random player as target (excluding local player)
                    local potentialTargets = {}
                    for _, player in ipairs(Players:GetPlayers()) do
                        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                            table.insert(potentialTargets, player)
                        end
                    end
                    
                    if #potentialTargets > 0 then
                        local randomPlayer = potentialTargets[math.random(1, #potentialTargets)]
                        local targetPos = randomPlayer.Character.HumanoidRootPart.Position
                        
                        -- Crazy movement
                        targetData.AlignPosition.Position = targetPos
                        targetData.Gyro.CFrame = CFrame.new(targetPos) * CFrame.Angles(
                            math.rad(math.random(-360, 360)),
                            math.rad(math.random(-360, 360)),
                            math.rad(math.random(-360, 360))
                        )
                        
                        -- Add force
                        part.Velocity = Vector3.new(math.random(-500, 500), math.random(-500, 500), math.random(-500, 500))
                        part.RotVelocity = Vector3.new(math.random(-500, 500), math.random(-500, 500), math.random(-500, 500))
                    end
                end
            end)
        end
    end))
end

function BasePartHandler:Stop()
    -- Disconnect all connections
    for _, connection in ipairs(self.Connections) do
        connection:Disconnect()
    end
    
    -- Clean up parts
    for _, targetData in ipairs(self.TargetParts) do
        pcall(function()
            if targetData.Part and targetData.Part.Parent then
                targetData.AlignPosition:Destroy()
                targetData.Gyro:Destroy()
                targetData.Attachment:Destroy()
                targetData.Part.CustomPhysicalProperties = nil
            end
        end)
    end
    
    -- Clear tables
    self.Connections = {}
    self.TargetParts = {}
end

-- Initialize everything
local function StartDestroyer()
    InitializeBypass()
    SetupNetwork()
    
    handler = BasePartHandler.new()
    handler:Start()
    
    -- Anti kick & crash
    spawn(function()
        while wait() do
            if LocalPlayer.Character then
                for _, connection in ipairs(getconnections(LocalPlayer.Character.DescendantAdded)) do
                    connection:Disable()
                end
            end
            game:GetService("NetworkClient"):SetOutgoingKBPSLimit(math.huge)
        end
    end)
    return "Tpuaall Started"
end

-- Function to stop the destroyer
local function stopdestroyer()
    if handler then
        handler:Stop()
        handler = nil
        return "Tpuaall stopped"
    else
        return "No active Tpua to stop"
    end
end

AddCommand("reset", {"re"}, "Resets you", re)
AddCommand("fly", {"f"}, "Opens FLYGUI", function() return enableFlight() end)
AddCommand("noclip", {"nc"}, "Walk thru walls", ModeOn)
AddCommand("clip", {"noc"}, "Stops Noclip", ModeOff)

local swordkillActive = false
local swordkillTarget = "all"
local swordkillSilent = false
local originalTool = nil
local originalToolParent = nil
local deadPlayers = {} -- Track dead players

-- List of tool names that should be considered as swords
local SWORD_NAMES = {
    "sword", "foil", "blade", "katana", "saber", "rapier", "cutlass", "dagger",
    "knife", "longsword", "shortsword", "scimitar", "falchion", "broadsword"
}

-- Function to check if a tool is a sword
local function isSword(tool)
    if not tool then return false end
    local toolName = tool.Name:lower()
    for _, name in ipairs(SWORD_NAMES) do
        if toolName:find(name) then
            return true
        end
    end
    return false
end

-- Function to find the first sword in player's inventory
local function findSword(player)
    -- Check character first
    for _, tool in ipairs(player.Character:GetChildren()) do
        if tool:IsA("Tool") and isSword(tool) then
            return tool
        end
    end
    
    -- Check backpack
    local backpack = player:FindFirstChild("Backpack")
    if backpack then
        for _, tool in ipairs(backpack:GetChildren()) do
            if tool:IsA("Tool") and isSword(tool) then
                return tool
            end
        end
    end
    
    return nil
end

-- Function to force equip a tool
local function forceEquip(tool)
    if not tool then return end
    local player = game:GetService("Players").LocalPlayer
    if not player.Character then return end
    
    -- Save current tool if it's different
    if not originalTool or originalTool ~= tool then
        originalTool = player.Character:FindFirstChildOfClass("Tool")
        if originalTool then
            originalToolParent = originalTool.Parent
        end
    end
    
    -- Equip the new tool
    if tool.Parent ~= player.Character then
        tool.Parent = player.Character
    end
    
    -- Wait for tool to equip
    task.wait(0.1)
    return tool
end

-- Function to restore original tool
local function restoreOriginalTool()
    if originalTool and originalToolParent then
        originalTool.Parent = originalToolParent
        originalTool = nil
        originalToolParent = nil
    end
end

-- Function to setup death listener for a player
local function setupDeathListener(player)
    if deadPlayers[player] then return end
    
    local function onCharacterAdded(character)
        if not swordkillActive then return end
        
        local humanoid = character:WaitForChild("Humanoid", 5)
        if humanoid then
            deadPlayers[player] = nil -- Player respawned
            
            humanoid.Died:Connect(function()
                deadPlayers[player] = true
            end)
        end
    end
    
    if player.Character then
        local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid.Died:Connect(function()
                deadPlayers[player] = true
            end)
        end
    end
    
    player.CharacterAdded:Connect(onCharacterAdded)
end

AddCommandWithPlayer("swordkill", "skill", "Kills players using a sword tool [TOOL]", function(name)
    local Players = game:GetService("Players")
    local player = Players.LocalPlayer
    swordkillActive = true
    deadPlayers = {} -- Reset dead players tracking
    
    -- Set target
    if name == "all" then
        swordkillTarget = "all"
        -- Setup death listeners for all players
        for _, target in ipairs(Players:GetPlayers()) do
            if target ~= player then
                setupDeathListener(target)
            end
        end
    else
        local target = GetPlayer(name)
        if not target then showNotification("Target not found!", true) end
        if typeof(target) == "table" then target = target[1] end
        swordkillTarget = target.Name
        setupDeathListener(target)
    end
    
    -- Check if we have a sword
    local sword = findSword(player)
    if not sword then
        -- Try to find any tool that might work
        sword = player.Character:FindFirstChildOfClass("Tool") or 
               (player.Backpack and player.Backpack:FindFirstChildOfClass("Tool"))
        if not sword then
            return "No sword found!"
        end
    end
    
    -- Start kill loop
    coroutine.wrap(function()
        while swordkillActive do
            local character = player.Character
            if not character then task.wait(0.1) continue end
            
            -- Find sword (in case it changed)
            local sword = findSword(player) or character:FindFirstChildOfClass("Tool")
            if not sword or not sword:FindFirstChild("Handle") then 
                task.wait(0.1) 
                continue 
            end
            
            if swordkillTarget == "all" then
                -- Kill all players except yourself
                for _, target in ipairs(Players:GetPlayers()) do
                    if target ~= player and target.Character and not deadPlayers[target] then
                        local humanoid = target.Character:FindFirstChildOfClass("Humanoid")
                        if humanoid and humanoid.Health > 0 then
                            -- Only equip sword when needed
                            sword = forceEquip(sword)
                            local handle = sword.Handle
                            
                            if not swordkillSilent then
                                sword:Activate()
                            end
                            
                            -- Touch all parts of the character
                            for _, part in ipairs(target.Character:GetChildren()) do
                                if part:IsA("BasePart") then
                                    firetouchinterest(handle, part, 0)
                                    firetouchinterest(handle, part, 1)
                                end
                            end
                        end
                    elseif deadPlayers[target] then
                        -- Player is dead, unequip sword
                        if sword.Parent == player.Character then
                            sword.Parent = player.Backpack
                        end
                    end
                end
            else
                -- Kill specific target
                local target = Players:FindFirstChild(swordkillTarget)
                if target and target.Character and not deadPlayers[target] then
                    local humanoid = target.Character:FindFirstChildOfClass("Humanoid")
                    if humanoid and humanoid.Health > 0 then
                        -- Equip sword only when attacking
                        sword = forceEquip(sword)
                        local handle = sword.Handle
                        
                        if not swordkillSilent then
                            sword:Activate()
                        end
                        
                        -- Touch all parts of the character
                        for _, part in ipairs(target.Character:GetChildren()) do
                            if part:IsA("BasePart") then
                                firetouchinterest(handle, part, 0)
                                firetouchinterest(handle, part, 1)
                            end
                        end
                    end
                elseif target and deadPlayers[target] then
                    -- Target is dead, unequip sword
                    if sword.Parent == player.Character then
                        sword.Parent = player.Backpack
                    end
                end
            end
            
            task.wait(0.1)
        end
        
        -- Restore original tool when done
        restoreOriginalTool()
    end)()
    
    return "Sword killed\n" .. (swordkillTarget == "all" and "all players" or swordkillTarget)
end)

AddCommand("unswordkill ", "unskill", "Stops the sword kill process", function()
    swordkillActive = false
    restoreOriginalTool()
    return "Sword kill stopped"
end)

-- Setup player tracking
game:GetService("Players").PlayerAdded:Connect(function(player)
    if swordkillActive and swordkillTarget == "all" then
        setupDeathListener(player)
    end
end)

local bkillall = false  -- Default to targeting specific players
local bkillActive = false

AddCommandWithPlayer("btoolkill", "bkill", "Deletes part of the target player using Building Tools [TOOL]", function(name)
    local Players = game:GetService("Players")
    local player = Players.LocalPlayer
    bkillActive = true

    local targets
    if bkillall then
        -- Get all players except local player
        targets = {}
        for _, p in ipairs(Players:GetPlayers()) do
            if p ~= player then
                table.insert(targets, p)
            end
        end
    else
        -- Use the specified target
        targets = GetPlayer(name)
        if not targets then showNotification("Target not found!", true) end
        if typeof(targets) ~= "table" then targets = {targets} end
    end

    -- Death listener
    local function setupDeathListener(character)
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid.Died:Connect(function()
                bkillActive = false
            end)
        end
    end

    if player.Character then
        setupDeathListener(player.Character)
    end

    player.CharacterAdded:Connect(function(character)
        if not bkillActive then return end
        setupDeathListener(character)
    end)

    -- Start bkill loop
    coroutine.wrap(function()
        while bkillActive do
            local character = player.Character
            if not character then task.wait(0.1) continue end

            local rootPart = character:FindFirstChild("HumanoidRootPart")
            if not rootPart then task.wait(0.1) continue end

            -- Using name call to find tools more efficiently
            local btools = player:FindFirstChild("Backpack") and player.Backpack:FindFirstChild("Building Tools") or nil
            if not btools then 
                btools = player.Character:FindFirstChild("Building Tools") or nil
                if not btools then 
                    task.wait(0.1) 
                    continue 
                end
            end

            local syncAPI = btools:FindFirstChild("SyncAPI")
            if not syncAPI then task.wait(0.1) continue end

            local serverEndpoint = syncAPI:FindFirstChild("ServerEndpoint")
            if not serverEndpoint then task.wait(0.1) continue end

            for _, target in ipairs(targets) do
                if target ~= player and target.Character then
                    local otherRoot = target.Character:FindFirstChild("HumanoidRootPart")
                    if otherRoot then
                        local torso = target.Character:FindFirstChild("Torso") or target.Character:FindFirstChild("UpperTorso")
                        if torso then
                            local args = {
                                "Remove",
                                {
                                    torso
                                }
                            }
                            pcall(function()
                                serverEndpoint:InvokeServer(unpack(args))
                            end)
                        end
                    end
                end
            end

            task.wait(0.1)
        end
    end)()

    return "Bkilled\n" .. (bkillall and "players" or "target(s)")
end)

AddCommand("unbtoolkill", "unbkill", "Stops the bkill process", function()
    bkillActive = false
    return "Bkill stopped"
end)

AddCommand("btoolkillall", "bkillall", "Enable killing everyone except yourself", function()
    bkillall = true
    return "BKill all enabled"
end)

AddCommand("unbtoolkillall", "unbkillall", "Disable killing everyone except yourself", function()
    bkillall = false
    return "BKill all disabled"
end)

AddCommand("walkfling", {"wf"}, "Starts Touchfling", TFlingOn)
AddCommand("unwalkfling", {"unwf"}, "Stops Touchfling", TFlingOff)

AddCommandWithPlayer("kill", {"fling"}, "Fling a player", function(name)
    local target = GetPlayer(name)
    if not target then showNotification("Target not found!", true) end
    return SkidFling(target)
end)

AddCommand("killall", {"flingall"}, "Fling all players", function()
    local players = Players:GetPlayers()
    local count = 0
    
    for _, player in ipairs(players) do
        if player ~= Player then
            SkidFling(player)
            count = count + 1
            task.wait(0.5) -- Small delay between flings
        end
    end
    
    return "Flinging\n"..count.." players"
end)

AddCommand("Invisible", {"invis"}, "Hides you [R6 RECOMMENDED]", invis2)
AddCommand("visible", {"vis"}, "Shows you", vis2)
AddCommand("antibang", {"ab"}, "use when banged", StartAB)
AddCommand("antifling", {"af"}, "Prevents exploiter flings", Afon)
AddCommand("unantifling", {"unaf"}, "Vulnerable to exploiter flings", Afoff)
AddCommand("antiafk", {"aafk"}, "Prevents idle kick", antiafkon)
AddCommand("unantiafk", {"unaafk"}, "Stops Anti-Afk", antiafkoff)
AddCommand("antilag", {"al"}, "Reduces Lags", al11)
AddCommand("invertgrav", {"igrav"}, "Inverts UnachoredParts Gravity", GravOn)
AddCommand("uninvertgrav", {"unigrav"}, "Stopps Inverting UnachoredParts Gravity", GravOff)
AddCommand("telekinesis", {"tk"}, "Move any UnachoredParts", tk)
AddCommand("partmover", {"pm"}, "Move any UnachoredParts like Btools", partm)
AddCommand("blackhole", {"bh"}, "Sucks UnachoredParts", blackHoleScript)
AddCommand("unblackhole", {"unbh"}, "stops sucking UnachoredParts", disableBlackHole)
AddCommand("ringparts", "rp", "Loads The Ringparts Gui", R1)
AddCommand("tpuaall", "bpall", "Tps unachored to everyone", StartDestroyer)
AddCommand("untpuaall", "unbpall", "Stops Tpuaall", stopdestroyer)

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local LocalPlayer = Players.LocalPlayer

-- Blackhole system (only initialized when needed)
local Blackhole = {
    Active = false,
    Attachment1 = nil,
    Folder = nil,
    AnchorPart = nil,
    HumanoidRootPart = nil,
    Connections = {},
    ModifiedParts = {}
}

-- Network optimization (only initialized when needed)
local Network = {
    Initialized = false,
    BaseParts = {},
    Velocity = Vector3.new(14.46262424, 14.46262424, 14.46262424),
    HeartbeatConnection = nil
}

-- Initialize network system (only when first needed)
local function InitializeNetwork()
    if not Network.Initialized then
        Network.HeartbeatConnection = RunService.Heartbeat:Connect(function()
            sethiddenproperty(LocalPlayer, "SimulationRadius", math.huge)
            for _, part in pairs(Network.BaseParts) do
                if part and part:IsDescendantOf(Workspace) then
                    part.Velocity = Network.Velocity
                end
            end
        end)
        Network.Initialized = true
    end
end

-- Retain part in network system
local function RetainPart(part)
    if part:IsA("BasePart") and part:IsDescendantOf(Workspace) then
        table.insert(Network.BaseParts, part)
        part.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
        part.CanCollide = false
    end
end

-- Create hidden anchor part (only when needed)
local function CreateAttachmentPart()
    if not Blackhole.Folder then
        Blackhole.Folder = Instance.new("Folder")
        Blackhole.Folder.Name = "BlackholeSystem"
        Blackhole.Folder.Parent = Workspace
        
        Blackhole.AnchorPart = Instance.new("Part")
        Blackhole.AnchorPart.Name = "BlackholeAnchor"
        Blackhole.AnchorPart.Anchored = true
        Blackhole.AnchorPart.CanCollide = false
        Blackhole.AnchorPart.Transparency = 1
        Blackhole.AnchorPart.Size = Vector3.new(0.1, 0.1, 0.1)
        Blackhole.AnchorPart.Parent = Blackhole.Folder
        
        Blackhole.Attachment1 = Instance.new("Attachment")
        Blackhole.Attachment1.Name = "BlackholeAttachment"
        Blackhole.Attachment1.Parent = Blackhole.AnchorPart
    end
end

-- Clean up a modified part
local function CleanPart(part)
    if part and part:IsA("BasePart") then
        -- Restore original properties if we stored them
        if Blackhole.ModifiedParts[part] then
            local original = Blackhole.ModifiedParts[part]
            part.CanCollide = original.CanCollide
            part.CustomPhysicalProperties = original.CustomPhysicalProperties
            Blackhole.ModifiedParts[part] = nil
        end
        
        -- Remove created instances
        for _, child in ipairs(part:GetChildren()) do
            if child.Name == "BlackholeAttachment" or 
               child.Name == "BlackholeAlignPosition" or
               child.Name == "BlackholeTorque" then
                child:Destroy()
            end
        end
    end
end

-- Function to "blackhole" parts
local function ForcePart(part)
    if part:IsA("BasePart") and not part.Anchored and
       not part.Parent:FindFirstChildOfClass("Humanoid") and
       not part.Parent:FindFirstChild("Head") and
       part.Name ~= "Handle" then
        
        -- Store original properties
        if not Blackhole.ModifiedParts[part] then
            Blackhole.ModifiedParts[part] = {
                CanCollide = part.CanCollide,
                CustomPhysicalProperties = part.CustomPhysicalProperties
            }
        end
        
        -- Clean up existing movers
        for _, child in ipairs(part:GetChildren()) do
            if child:IsA("BodyMover") or child:IsA("RocketPropulsion") then
                child:Destroy()
            end
        end
        
        part.CanCollide = false
        part.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
        
        -- Create new attachment if needed
        if not part:FindFirstChild("BlackholeAttachment") then
            local attachment = Instance.new("Attachment")
            attachment.Name = "BlackholeAttachment"
            attachment.Parent = part
            
            local torque = Instance.new("Torque")
            torque.Name = "BlackholeTorque"
            torque.Torque = Vector3.new(100000, 100000, 100000)
            torque.Attachment0 = attachment
            torque.Parent = part
            
            local alignPos = Instance.new("AlignPosition")
            alignPos.Name = "BlackholeAlignPosition"
            alignPos.MaxForce = math.huge
            alignPos.MaxVelocity = math.huge
            alignPos.Responsiveness = 200
            alignPos.Attachment0 = attachment
            alignPos.Attachment1 = Blackhole.Attachment1
            alignPos.Parent = part
        end
        
        RetainPart(part)
    end
end

-- Start bringing parts
local function StartBringParts(target)
    InitializeNetwork()
    CreateAttachmentPart()
    
    local character = target.Character or target.CharacterAdded:Wait()
    Blackhole.HumanoidRootPart = character:WaitForChild("HumanoidRootPart")
    
    Blackhole.Active = true
    
    -- Process existing parts
    for _, part in ipairs(Workspace:GetDescendants()) do
        ForcePart(part)
    end
    
    -- Connect to new parts
    Blackhole.Connections.DescendantAdded = Workspace.DescendantAdded:Connect(function(part)
        if Blackhole.Active then
            ForcePart(part)
        end
    end)
    
    -- Update position loop
    Blackhole.Connections.RenderStepped = RunService.RenderStepped:Connect(function()
        if Blackhole.Active and Blackhole.Attachment1 and Blackhole.HumanoidRootPart then
            Blackhole.Attachment1.WorldCFrame = Blackhole.HumanoidRootPart.CFrame
        end
    end)
    
    return "Tpua\n" .. target.Name
end

-- Stop bringing parts (full cleanup)
local function StopBringParts()
    Blackhole.Active = false
    
    -- Disconnect all connections
    for name, connection in pairs(Blackhole.Connections) do
        if connection then
            connection:Disconnect()
        end
        Blackhole.Connections[name] = nil
    end
    
    -- Clean up modified parts
    for part, _ in pairs(Blackhole.ModifiedParts) do
        if part then
            CleanPart(part)
        end
    end
    Blackhole.ModifiedParts = {}
    
    -- Clean up anchor system
    if Blackhole.Folder then
        Blackhole.Folder:Destroy()
        Blackhole.Folder = nil
        Blackhole.Attachment1 = nil
        Blackhole.AnchorPart = nil
    end
    
    -- Clear network parts (but keep network system running)
    Network.BaseParts = {}
    
    return "Stopped Tpua"
end

-- Commands
AddCommandWithPlayer("tpua", "bp", "Tps unanchored to player", function(name)
    local target = GetPlayer(name)
    if not target then showNotification("Target not found!", true) end
    return StartBringParts(target)
end)

AddCommand("untpua", "unbp", "Stops Tpua", function()
    return StopBringParts()
end)

AddCommand("tornado", {"td"}, "Loads Tornado Gui", tornado)
AddCommand("partcontroller", {"pc"}, "Loads Partcontroller", PCR)
AddCommand("players", {"plrs"}, "Opens the players list", plrz)
AddCommand("ragdoll", {"rag"}, "Ragdoll Tool", rag)
AddCommand("console", {"cn"}, "Opens Console", Con)
AddCommand("dex", {"explorer"}, "Opens Dex Explorer", DexExe)
AddCommand("numero", {"nware"}, "really cool gui 8) [18+]", kfw)
AddCommand("f3x", {"fex"}, "Loads Btools (CLIENT)", fex)
AddCommand("f3xpanel", {"fexp"}, "Loads Btools panel [TOOL]", fexpanel)
AddCommand("sit", nil, "Makes you sit", sit)
AddCommand("cmdlooper", {"cmdl"}, "CmdLooper for HD Admin", cmdl)
AddCommand("voidprotection", {"voidp"}, "Protects you from the void", VoidProtectionOn)
AddCommand("unvoidprotection", {"unvoidp"}, "Stops VoidProtection", VoidProtectionOff)
AddCommand("dropalltools", {"dat"}, "Drops all your tools", DAT)
AddCommand("unvcban", {"vban"}, "Removes VoiceChat Ban", Vcban)
AddCommand("toolcontrol", {"tc"}, "Control any tool [Tool]", tc)

-- New commands with aliases


-- Hitbox command
local originalSizes = {} -- Stores original sizes of HRPs
local hitboxEnabled = false
local currentSize = 0
local connections = {} -- Stores player connections to clean up later

-- Function to apply hitbox to a character
local function applyHitbox(character, player)
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if hrp then
        -- Store original size if we haven't already
        if not originalSizes[player] then
            originalSizes[player] = hrp.Size
        end
        
        if hitboxEnabled then
            -- Apply hitbox size
            hrp.Size = Vector3.new(currentSize, currentSize, currentSize)
            hrp.Transparency = 0.9
            hrp.Material = Enum.Material.Neon
            hrp.Color = Color3.fromRGB(255, 0, 0) -- Red color for visibility
        else
            -- Reset to original size
            hrp.Size = originalSizes[player]
            hrp.Transparency = 0
            hrp.Material = Enum.Material.Plastic
            hrp.Color = Color3.fromRGB(13, 105, 172) -- Default blue color
        end
    end
end

-- Function to handle character added events
local function setupPlayer(player)
    -- Clean up any existing connection for this player
    if connections[player] then
        connections[player]:Disconnect()
        connections[player] = nil
    end
    
    -- Set up new connection
    connections[player] = player.CharacterAdded:Connect(function(character)
        applyHitbox(character, player)
    end)
    
    -- Apply to existing character if it exists
    if player.Character then
        applyHitbox(player.Character, player)
    end
end

-- Cleanup function
local function cleanup()
    hitboxEnabled = false
    currentSize = 0
    
    -- Disconnect all player connections
    for player, connection in pairs(connections) do
        connection:Disconnect()
    end
    connections = {}
    
    -- Reset all hitboxes
    for player, originalSize in pairs(originalSizes) do
        if player.Character then
            local hrp = player.Character:FindFirstChild("HumanoidRootPart")
            if hrp then
                hrp.Size = originalSize
                hrp.Transparency = 0
                hrp.Material = Enum.Material.Plastic
                hrp.Color = Color3.fromRGB(13, 105, 172)
            end
        end
    end
end

-- Main command
AddCommandWithValue("hitbox", "amount", "reach", "Changes other players hitbox size (0 to reset)", function(size)
    local sizeNum = tonumber(size)
    if not sizeNum then return "Invalid size value" end
    
    -- Clean up if resetting
    if sizeNum == 0 then
        cleanup()
        return "Hitboxes reset to normal"
    end
    
    -- Set new state
    hitboxEnabled = true
    currentSize = sizeNum
    
    -- Setup existing players
    for _, player in ipairs(game:GetService("Players"):GetPlayers()) do
        if player ~= game.Players.LocalPlayer then
            setupPlayer(player)
        end
    end
    
    -- Setup future players
    if not connections.playerAdded then
        connections.playerAdded = game:GetService("Players").PlayerAdded:Connect(function(player)
            setupPlayer(player)
        end)
    end
    
    return "Hitbox size set to "..sizeNum
end)

-- Clean up when local player respawns
game.Players.LocalPlayer.CharacterAdded:Connect(function()
    if hitboxEnabled then
        -- Reapply hitboxes to all players
        for _, player in ipairs(game:GetService("Players"):GetPlayers()) do
            if player ~= game.Players.LocalPlayer and player.Character then
                applyHitbox(player.Character, player)
            end
        end
    end
end)

-- Clean up when script ends
game:GetService("Players").LocalPlayer.CharacterRemoving:Connect(cleanup)

AddCommandWithValue("jumppower", "amount", "jp", "Sets your jump power", function(power)
    local num = tonumber(power)
    if not num then return "Invalid number" end
    
    local humanoid = game.Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        humanoid.JumpPower = num
        return "Jump power set to "..num
    end
    return "Humanoid not found"
end)

AddCommandWithValue("gravity", "value", "grav", "Sets workspace gravity", function(value)
    local num = tonumber(value)
    if not num then return "Invalid number" end
    
    workspace.Gravity = num
    return "Gravity set to\n"..num
end)

AddCommandWithValue("hipheight", "amount", "hh", "Sets your hip height", function(height)
    local num = tonumber(height)
    if not num then return "Invalid number" end
    
    local humanoid = game.Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        humanoid.HipHeight = num
        return "Hip height set to\n"..num
    end
    return "Humanoid not found"
end)

local RunService = game:GetService("RunService")

local spinning = nil -- connection holder

AddCommandWithValue("spin", "speed", nil, "Spin your character at the given speed", function(value)
    local speed = tonumber(value)
    if not speed then
        return "Invalid spin speed"
    end

    local character = game.Players.LocalPlayer.Character
    if not character then
        return "Character not found"
    end

    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then
        return "HumanoidRootPart not found"
    end

    -- Stop previous spin if active
    if spinning then
        spinning:Disconnect()
        spinning = nil
    end

    -- Start new spin loop
    spinning = RunService.Heartbeat:Connect(function(dt)
        if character and character.Parent and hrp then
            hrp.CFrame = hrp.CFrame * CFrame.Angles(0, math.rad(speed), 0)
        end
    end)

    return "Spinning at\n" .. speed
end)

AddCommand("unspin", nil, "Stop spinning your character", function()
    if spinning then
        spinning:Disconnect()
        spinning = nil
        return "Spin stopped"
    else
        return "Stopped spinning"
    end
end)

local fpsCounterEnabled = false
local fpsCounterConnection = nil

-- Create or get existing ScreenGui
local player = game:GetService("Players").LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")
local screenGui = playerGui:FindFirstChild("ScreenGui") or Instance.new("ScreenGui")
screenGui.Name = "ScreenGui"
screenGui.Parent = playerGui

AddCommand("fps", nil, "Toggles FPS counter", function()
    fpsCounterEnabled = not fpsCounterEnabled

    if fpsCounterEnabled then
        -- Create label
        local fpsLabel = Instance.new("TextLabel")
        fpsLabel.Name = "FPSCounter"
        fpsLabel.Text = "FPS: 0"
        fpsLabel.TextColor3 = Color3.new(0,255,0)
        fpsLabel.BackgroundTransparency = 1
        fpsLabel.Size = UDim2.new(0, 100, 0, 30)  -- Changed height from 300 to 30 (more reasonable for text)
        fpsLabel.Position = UDim2.new(0, 12, 0, 44)
        fpsLabel.Font = Enum.Font.Arcade
        fpsLabel.TextSize = 19
        fpsLabel.TextXAlignment = Enum.TextXAlignment.Left
        fpsLabel.Parent = screenGui

        -- FPS logic
        local lastTime = tick()
        local frames = 0

        fpsCounterConnection = game:GetService("RunService").RenderStepped:Connect(function()
            frames += 1
            local currentTime = tick()
            if currentTime - lastTime >= 1 then
                fpsLabel.Text = "FPS: " .. tostring(frames)
                frames = 0
                lastTime = currentTime
            end
        end)

        return "FPS counter enabled"
    else
        -- Disable FPS
        if fpsCounterConnection then
            fpsCounterConnection:Disconnect()
            fpsCounterConnection = nil
        end

        local existing = screenGui:FindFirstChild("FPSCounter")
        if existing then
            existing:Destroy()
        end

        return "FPS counter disabled"
    end
end)

-- Fullbright command
local fullbrightEnabled = false
local originalLighting

AddCommand("fullbright", {"fb"}, "Toggles fullbright mode", function()
    fullbrightEnabled = not fullbrightEnabled
    local lighting = game:GetService("Lighting")
    
    if fullbrightEnabled then
        originalLighting = {
            Ambient = lighting.Ambient,
            Brightness = lighting.Brightness,
            GlobalShadows = lighting.GlobalShadows
        }
        
        lighting.Ambient = Color3.new(1,1,1)
        lighting.Brightness = 1
        lighting.GlobalShadows = false
        
        return "Fullbright enabled"
    else
        if originalLighting then
            lighting.Ambient = originalLighting.Ambient
            lighting.Brightness = originalLighting.Brightness
            lighting.GlobalShadows = originalLighting.GlobalShadows
        end
        
        return "Fullbright disabled"
    end
end)

-- Rejoin command
AddCommand("rejoin", {"rj"}, "Rejoins the same game", function()
    game:GetService("TeleportService"):Teleport(game.PlaceId)
    return "Rejoining game..."
end)

-- Server Hop command
AddCommand("serverhop", {"sh"}, "Joins a random server", function()
    local Http = game:GetService("HttpService")
    local TeleportService = game:GetService("TeleportService")
    
    local servers = Http:JSONDecode(game:HttpGet("https://games.roblox.com/v1/games/"..game.PlaceId.."/servers/Public?sortOrder=Asc&limit=100"))
    
    for _, server in ipairs(servers.data) do
        if server.playing < server.maxPlayers and server.id ~= game.JobId then
            TeleportService:TeleportToPlaceInstance(game.PlaceId, server.id)
            return "Server hopping..."
        end
    end
    
    return "No available\nservers found"
end)

-- Copy Position command
AddCommand("copypos", {"cp"}, "Copies your current position to clipboard", function()
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return "Character not found" end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return "HumanoidRootPart not found" end
    
    local position = hrp.Position
    local text = string.format("Vector3.new(%d, %d, %d)", position.X, position.Y, position.Z)
    
    setclipboard(text)
    return "copied to clipboard:\n"..text
end)

-- Size command
AddCommandWithValue("size", "amount", "scale", "Scales your character size", function(scale)
    local num = tonumber(scale)
    if not num or num <= 0 or num > 10 then return "Invalid scale (0.1-10)" end
    
    local character = game.Players.LocalPlayer.Character
    if not character then return "Character not found" end
    
    for _, part in ipairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            part.Size = part.Size * num
        end
    end
    
    return "scaled to\n"..num.."x"
end)

-- Enable fakelag with adjustable delay
AddCommandWithValue("fakelag", "delay", "flag", "Makes you look  like you have Lag", function(delay)
    local waitTime = tonumber(delay)
    if not waitTime or waitTime <= 0 then
        return "Usage: fakelag [delay]\nExample: fakelag 0.1"
    end

    -- Disable existing fakelag if active
    if _G.FakeLagEnabled then
        _G.FakeLagEnabled = false
        if _G.FakeLagThread then
            task.cancel(_G.FakeLagThread)
            _G.FakeLagThread = nil
        end
        -- Unanchor character when disabling
        local player = game.Players.LocalPlayer
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            player.Character.HumanoidRootPart.Anchored = false
        end
    end

    -- Enable new fakelag
    _G.FakeLagEnabled = true
    _G.FakeLagWaitTime = waitTime

    _G.FakeLagThread = task.spawn(function()
        local player = game.Players.LocalPlayer
        while _G.FakeLagEnabled and task.wait(waitTime) do
            local char = player.Character
            if char and char:FindFirstChild("HumanoidRootPart") then
                -- Freeze character for 0.4 seconds (adjustable)
                char.HumanoidRootPart.Anchored = true
                task.wait(0.4)
                if char and char:FindFirstChild("HumanoidRootPart") then
                    char.HumanoidRootPart.Anchored = false
                end
            end
        end
    end)

    return "Fakelag enabled\n(delay: " .. waitTime .. "s)"
end)

-- Disable fakelag
AddCommand("unfakelag", "unflag", "Disables fakelag", function()
    if _G.FakeLagEnabled then
        _G.FakeLagEnabled = false
        if _G.FakeLagThread then
            task.cancel(_G.FakeLagThread)
            _G.FakeLagThread = nil
        end
        -- Unanchor character
        local player = game.Players.LocalPlayer
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            player.Character.HumanoidRootPart.Anchored = false
        end
        return "Fakelag disabled"
    else
        return "Fakelag was not active"
    end
end)

AddCommandWithValue("animspeed", "value", "as", "Sets animation speed (1 = default)", function(value)
    local speed = tonumber(value)
    if not speed or speed <= 0 or speed > 10 then
        return "Invalid animation speed (must be between 0.1 and 10)"
    end

    local player = game.Players.LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()

    -- Start a loop to continuously apply speed
    if character:FindFirstChild("AnimationSpeedLoop") then
        character.AnimationSpeedLoop:Destroy() -- Remove old loop if it exists
    end

    local loopMarker = Instance.new("BoolValue")
    loopMarker.Name = "AnimationSpeedLoop"
    loopMarker.Parent = character

    task.spawn(function()
        while loopMarker.Parent do
            task.wait()
            local humanoid = character:FindFirstChildOfClass("Humanoid") or character:FindFirstChildOfClass("AnimationController")
            if not humanoid then continue end

            for _, track in ipairs(humanoid:GetPlayingAnimationTracks()) do
                track:AdjustSpeed(speed)
            end
        end
    end)

    return "animspeed set to\n" .. speed
end)

-- Set max camera zoom only (does NOT change min zoom)
AddCommandWithValue("zoom", "value", "z", "Sets max camera zoom distance", function(value)
    local num = tonumber(value)
    if not num or num < 0 then
        return "Invalid zoom value"
    end

    local player = game.Players.LocalPlayer
    player.CameraMaxZoomDistance = num

    return "Zoom set to\n" .. num
end)

-- Reset zoom to Roblox defaults (min stays at default 0.5, max at 128)
AddCommand("resetzoom", {"rz"}, "Reset zoom distance to default", function()
    local player = game.Players.LocalPlayer
    player.CameraMaxZoomDistance = 128

    return "Zoom reset to default"
end)

-- Set camera field of view
AddCommandWithValue("fov", "value", nil, "Sets camera Field of View", function(value)
    local num = tonumber(value)
    if not num or num < 1 or num > 120 then
        return "FOV must be between 1 and 120"
    end

    workspace.CurrentCamera.FieldOfView = num
    return "FOV set to\n" .. num
end)

-- Helper: Find a player by partial username or display name
local function FindPlayer(name)
    name = name:lower()
    for _, player in ipairs(game.Players:GetPlayers()) do
        if player.Name:lower():sub(1, #name) == name or player.DisplayName:lower():sub(1, #name) == name then
            return player
        end
    end
    return nil
end

local currentViewConnection -- to disconnect old connections
local currentViewedPlayer -- to track which player is being viewed

AddCommandWithPlayer("view", nil, "View a player", function(name)
    local targetPlayer = FindPlayer(name)
    if not targetPlayer then
        showNotification("Target not found!", true)
    end
    
    -- If already viewing this player, stop viewing
    if currentViewedPlayer == targetPlayer then
        if currentViewConnection then
            currentViewConnection:Disconnect()
            currentViewConnection = nil
        end
        currentViewedPlayer = nil
        return "Stopped viewing\n" .. targetPlayer.Name
    end
    
    local function updateView(character)
        if not character then return end
        
        -- Wait for humanoid to exist (might not be immediately available after respawn)
        local humanoid = character:WaitForChild("Humanoid", 5) or character:FindFirstChildWhichIsA("Humanoid")
        local hrp = character:FindFirstChild("HumanoidRootPart")
        
        if humanoid then
            workspace.CurrentCamera.CameraSubject = humanoid
        elseif hrp then
            workspace.CurrentCamera.CameraSubject = hrp
        end
    end

    -- Disconnect previous connection if viewing another player
    if currentViewConnection then
        currentViewConnection:Disconnect()
        currentViewConnection = nil
    end

    -- Update view immediately
    updateView(targetPlayer.Character)

    -- Listen for respawn
    currentViewConnection = targetPlayer.CharacterAdded:Connect(updateView)
    currentViewedPlayer = targetPlayer

    return "Viewing\n" .. targetPlayer.Name
end)

AddCommand("unview", nil, "Reset camera back to yourself", function()
    -- Clear viewing state
    if currentViewConnection then
        currentViewConnection:Disconnect()
        currentViewConnection = nil
    end
    currentViewedPlayer = nil
    
    -- Reset to local player
    local player = game.Players.LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    
    local humanoid = character:WaitForChild("Humanoid", 5) or character:FindFirstChildWhichIsA("Humanoid")
    local hrp = character:FindFirstChild("HumanoidRootPart")

    if humanoid then
        workspace.CurrentCamera.CameraSubject = humanoid
    elseif hrp then
        workspace.CurrentCamera.CameraSubject = hrp
    end

    return "Stopped viewing"
end)

-- Fixed version of the goto command
AddCommandWithPlayer("goto", {"tp"}, "Teleport to a player", function(name)
    local targetPlayer = FindPlayer(name)
    if not targetPlayer then showNotification("Target not found!", true) end

    local character = game.Players.LocalPlayer.Character
    if not character then return "Your character not found" end

    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return "Your HumanoidRootPart not found" end

    local targetCharacter = targetPlayer.Character
    if not targetCharacter then return "Target character not found" end

    local targetHRP = targetCharacter:FindFirstChild("HumanoidRootPart")
    if not targetHRP then return "Target HumanoidRootPart not found" end

    -- Offset behind the target
    local offset = CFrame.new(0, 0, 5)
    humanoidRootPart.CFrame = targetHRP.CFrame * offset

    return "Teleported to\n" .. targetPlayer.Name
end)

AddCommand("teleporttool", {"tptool"}, "Click any where to teleport", CreateTptool)

-- Activate all tools command
AddCommand("aat", {"activatealltools"}, "Activates all tools in your inventory", function()
    local player = game.Players.LocalPlayer
    local backpack = player:FindFirstChild("Backpack")
    local character = player.Character
    
    if not backpack and not character then showNotification("Tools not found!", true) end
    
    local tools = {}
    
    -- Get tools from backpack
    if backpack then
        for _, item in ipairs(backpack:GetChildren()) do
            if item:IsA("Tool") then
                table.insert(tools, item)
            end
        end
    end
    
    -- Get tools from character
    if character then
        for _, item in ipairs(character:GetChildren()) do
            if item:IsA("Tool") then
                table.insert(tools, item)
            end
        end
    end
    
    if #tools == 0 then showNotification("Tools not found!", true) end
    
    -- Equip and activate all tools
    for _, tool in ipairs(tools) do
        if character then
            tool.Parent = character
            if tool:FindFirstChild("Activate") then
                tool.Activate:Fire()
            end
        end
    end
    
    return "Activated "..#tools.." tools"
end)

AddCommand("loopaat", {"laat"}, "activate all tools but it's looped", loopaat2)
AddCommand("unloopaat", {"unlaat"}, "Stops Loopaat", unloopaat1)

-- ESP command
local espEnabled = false
local espObjects = {}

local function createESP(player)
    local character = player.Character
    if not character then return end
    
    local highlight = Instance.new("Highlight")
    highlight.Name = "ESP_Highlight"
    highlight.Adornee = character
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    
    -- Set color based on team
    if player.Team then
        if player.Team == game.Players.LocalPlayer.Team then
            highlight.FillColor = Color3.fromRGB(0, 0, 255) -- Blue for teammates
            highlight.OutlineColor = Color3.fromRGB(0, 0, 200)
        else
            highlight.FillColor = Color3.fromRGB(255, 0, 0) -- Red for enemies
            highlight.OutlineColor = Color3.fromRGB(200, 0, 0)
        end
    else
        highlight.FillColor = Color3.fromRGB(0, 255, 0) -- Green for neutral
        highlight.OutlineColor = Color3.fromRGB(0, 200, 0)
    end
    
    highlight.Parent = character
    
    -- Distance label
    local billboard = Instance.new("BillboardGui")
    billboard.Name = "ESP_Distance"
    billboard.Adornee = character:WaitForChild("Head") or character:WaitForChild("HumanoidRootPart")
    billboard.Size = UDim2.new(0, 200, 0, 50)
    billboard.StudsOffset = Vector3.new(0, 2, 0)
    billboard.AlwaysOnTop = true
    
    local label = Instance.new("TextLabel")
    label.Name = "ESP_Label"
    label.Size = UDim2.new(1, 0, 1, 0)
    label.BackgroundTransparency = 1
    label.Text = player.Name
    label.TextColor3 = Color3.new(1, 1, 1)
    label.TextScaled = true
    label.Parent = billboard
    
    billboard.Parent = character
    
    -- Store for cleanup
    espObjects[player] = {highlight, billboard}
    
    -- Update distance
    game:GetService("RunService").Heartbeat:Connect(function()
        if not character or not character:FindFirstChild("HumanoidRootPart") then return end
        if not game.Players.LocalPlayer.Character or not game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then return end
        
        local distance = (character.HumanoidRootPart.Position - game.Players.LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
        label.Text = string.format("%s [%d studs]", player.Name, math.floor(distance))
    end)
end

local function removeESP(player)
    if espObjects[player] then
        for _, obj in ipairs(espObjects[player]) do
            if obj then
                obj:Destroy()
            end
        end
        espObjects[player] = nil
    end
end

AddCommand("esp", nil, "Highlights all players with distance", function()
    if espEnabled then return "ESP is already enabled" end
    
    espEnabled = true
    
    -- ESP existing players
    for _, player in ipairs(game.Players:GetPlayers()) do
        if player ~= game.Players.LocalPlayer then
            createESP(player)
        end
    end
    
    -- ESP new players
    game.Players.PlayerAdded:Connect(function(player)
        if espEnabled then
            player.CharacterAdded:Connect(function(character)
                if espEnabled then
                    createESP(player)
                end
            end)
        end
    end)
    
    -- Handle character respawns
    for _, player in ipairs(game.Players:GetPlayers()) do
        if player ~= game.Players.LocalPlayer then
            player.CharacterAdded:Connect(function(character)
                if espEnabled then
                    createESP(player)
                end
            end)
        end
    end
    
    return "ESP enabled"
end)

AddCommand("unesp", nil, "Removes all ESP highlights", function()
    if not espEnabled then return "ESP is not enabled" end
    
    espEnabled = false
    
    for player, objects in pairs(espObjects) do
        for _, obj in ipairs(objects) do
            if obj then
                obj:Destroy()
            end
        end
    end
    
    espObjects = {}
    return "ESP disabled"
end)

-- Xray command
local xrayEnabled = false
local originalTransparencies = {}

local function enableXray()
    if xrayEnabled then return end
    
    xrayEnabled = true
    
    for _, part in ipairs(workspace:GetDescendants()) do
        if part:IsA("BasePart") and part.Transparency < 1 then
            originalTransparencies[part] = part.Transparency
            part.Transparency = 0.5
            part.LocalTransparencyModifier = 0.5
        end
    end
    
    -- Handle new parts
    workspace.DescendantAdded:Connect(function(part)
        if xrayEnabled and part:IsA("BasePart") and part.Transparency < 1 then
            originalTransparencies[part] = part.Transparency
            part.Transparency = 0.5
            part.LocalTransparencyModifier = 0.5
        end
    end)
end

local function disableXray()
    if not xrayEnabled then return end
    
    xrayEnabled = false
    
    for part, transparency in pairs(originalTransparencies) do
        if part:IsA("BasePart") then
            part.Transparency = transparency
            part.LocalTransparencyModifier = 0
        end
    end
    
    originalTransparencies = {}
end

AddCommand("xray", nil, "See through walls", function()
    enableXray()
    return "Xray enabled"
end)

AddCommand("unxray", nil, "Disables xray", function()
    disableXray()
    return "Xray disabled"
end)

-- Tool/object ESP command
local toolEspEnabled = false
local toolEspObjects = {}

local function createToolESP(tool)
    if not tool:IsA("BasePart") and not tool:IsA("Model") then return end
    
    local highlight = Instance.new("Highlight")
    highlight.Name = "ToolESP_Highlight"
    highlight.Adornee = tool
    highlight.FillColor = Color3.fromRGB(255, 165, 0) -- Orange
    highlight.OutlineColor = Color3.fromRGB(200, 130, 0)
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    highlight.Parent = tool
    
    -- Label
    local billboard = Instance.new("BillboardGui")
    billboard.Name = "ToolESP_Label"
    billboard.Adornee = tool:IsA("BasePart") and tool or tool:FindFirstChildWhichIsA("BasePart")
    billboard.Size = UDim2.new(0, 200, 0, 50)
    billboard.StudsOffset = Vector3.new(0, 2, 0)
    billboard.AlwaysOnTop = true
    
    local label = Instance.new("TextLabel")
    label.Name = "ToolESP_Text"
    label.Size = UDim2.new(1, 0, 1, 0)
    label.BackgroundTransparency = 1
    label.Text = tool.Name
    label.TextColor3 = Color3.new(1, 1, 1)
    label.TextScaled = true
    label.Parent = billboard
    
    billboard.Parent = tool
    
    -- Store for cleanup
    toolEspObjects[tool] = {highlight, billboard}
end

local function removeToolESP(tool)
    if toolEspObjects[tool] then
        for _, obj in ipairs(toolEspObjects[tool]) do
            if obj then
                obj:Destroy()
            end
        end
        toolEspObjects[tool] = nil
    end
end

local function scanForTools()
    for _, obj in ipairs(workspace:GetDescendants()) do
        if obj:IsA("Tool") or (obj:IsA("BasePart") and obj.Parent ~= workspace) then
            createToolESP(obj)
        end
    end
end

AddCommand("partesp", {"pesp"}, "Esps everything [LAG]", function()
    if toolEspEnabled then return "Part ESP is already enabled" end
    
    toolEspEnabled = true
    
    -- Scan existing tools
    scanForTools()
    
    -- Watch for new tools
    workspace.DescendantAdded:Connect(function(obj)
        if toolEspEnabled and (obj:IsA("Tool") or (obj:IsA("BasePart") and obj.Parent ~= workspace)) then
            createToolESP(obj)
        end
    end)
    
    return "Part ESP enabled"
end)

AddCommand("unpartesp", {"unpesp"}, "Removes all part ESP [WIP]", function()
    if not toolEspEnabled then return "Part ESP is not enabled" end
    
    toolEspEnabled = false
    
    for tool, objects in pairs(toolEspObjects) do
        for _, obj in ipairs(objects) do
            if obj then
                obj:Destroy()
            end
        end
    end
    
    toolEspObjects = {}
    return "Part ESP disabled"
end)

AddCommand("credits", {"c"}, "Shows the owner of the script", credits)


-- Create the main GUI
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "TopPrompt"
ScreenGui.ResetOnSpawn = false
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

-- Function to detect if the player is on mobile
local function isMobile()
    return UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled and not UserInputService.MouseEnabled
end

-- Function to initialize the GUI
local function initializeGUI()
    -- Clear any existing GUI elements
    for _, child in ipairs(ScreenGui:GetChildren()) do
        child:Destroy()
    end

    local MainFrame = Instance.new("Frame")
    MainFrame.Name = "MainFrame"
    MainFrame.BorderSizePixel = 0
    MainFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    MainFrame.BackgroundTransparency = 0.2
    
    -- Set position based on device type
    if isMobile() then
        MainFrame.Position = UDim2.new(0, 20, 0, 2)
    else
        MainFrame.Position = UDim2.new(0.5, -73, 1, -50)
    end
    
    MainFrame.Size = UDim2.new(0, 146, 0, 44)
    MainFrame.Parent = ScreenGui

    local UICorner = Instance.new("UICorner")
    UICorner.CornerRadius = UDim.new(1, 0)
    UICorner.Parent = MainFrame

    -- Enhanced Notification System with Typewriter Effect
    local function showNotification(message, isError)
        -- Create sleek notification frame
        local notification = Instance.new("Frame")
        notification.Name = "Notification"
        notification.BackgroundColor3 = isError and Color3.fromRGB(40, 20, 20) or Color3.fromRGB(20, 30, 20)
        notification.BackgroundTransparency = 0.2
        notification.BorderSizePixel = 0
        notification.Size = UDim2.new(0, 250, 0, 30)  -- Smaller size
        notification.Position = UDim2.new(0, 20, 0, 69)
        notification.ZIndex = 10
        notification.Parent = ScreenGui
        
        -- Add smooth corner rounding
        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 6)
        corner.Parent = notification
        
        -- Add subtle shadow effect
        local shadow = Instance.new("ImageLabel")
        shadow.Name = "Shadow"
        shadow.Image = "rbxassetid://1316045217"
        shadow.ImageColor3 = Color3.new(0, 0, 0)
        shadow.ImageTransparency = 0.8
        shadow.ScaleType = Enum.ScaleType.Slice
        shadow.SliceCenter = Rect.new(10, 10, 118, 118)
        shadow.BackgroundTransparency = 1
        shadow.Size = UDim2.new(1, 10, 1, 10)
        shadow.Position = UDim2.new(0, -5, 0, -5)
        shadow.ZIndex = 9
        shadow.Parent = notification
        
        -- Add modern text label
        local label = Instance.new("TextLabel")
        label.Name = "Text"
        label.Text = ""
        label.Font = Enum.Font.GothamMedium
        label.TextSize = 13
        label.TextColor3 = isError and Color3.fromRGB(255, 120, 120) or Color3.fromRGB(180, 255, 180)
        label.BackgroundTransparency = 1
        label.Size = UDim2.new(1, -20, 1, 0)
        label.Position = UDim2.new(0, 15, 0, 0)
        label.TextXAlignment = Enum.TextXAlignment.Left
        label.TextYAlignment = Enum.TextYAlignment.Center
        label.TextWrapped = false
        label.Parent = notification
        
        -- Add accent bar
        local accent = Instance.new("Frame")
        accent.Name = "Accent"
        accent.BackgroundColor3 = isError and Color3.fromRGB(255, 80, 80) or Color3.fromRGB(100, 255, 100)
        accent.BorderSizePixel = 0
        accent.Size = UDim2.new(0, 3, 0.7, 0)
        accent.Position = UDim2.new(0, 5, 0.15, 0)
        accent.ZIndex = 11
        accent.Parent = notification
        
        -- Round accent corners
        local accentCorner = Instance.new("UICorner")
        accentCorner.CornerRadius = UDim.new(1, 0)
        accentCorner.Parent = accent
        
        -- Play notification sound
        if clickSound then
            clickSound:Play() -- Play click sound when notification appears
        end
        
        -- Play error/success sound if defined
        if isError and errorSound then
            errorSound:Play()
        elseif successSound then
            successSound:Play()
        end
        
        -- Animation sequence
        notification.Size = UDim2.new(0, 0, 0, 30)
        notification.Position = UDim2.new(0, 20, 0, 69)
        
        -- Smooth expand animation
        local expand = TweenService:Create(notification, TweenInfo.new(0.2, Enum.EasingStyle.Quint), {
            Size = UDim2.new(0, 250, 0, 30)
        })
        expand:Play()
        
        -- Typewriter effect with click sounds
        local fullText = message
        local currentText = ""
        local charIndex = 0
        local typewriterConnection
        
        local function updateText()
            charIndex = charIndex + 1
            if charIndex <= #fullText then
                currentText = string.sub(fullText, 1, charIndex)
                label.Text = currentText
                
                -- Play click sound randomly during typing (60% chance per character)
                if clickSound and math.random() < 0.6 then
                    clickSound:Play()
                end
            else
                -- Stop the typewriter effect when done
                if typewriterConnection then
                    typewriterConnection:Disconnect()
                end
            end
        end
        
        -- Start typewriter effect (15ms per character)
        typewriterConnection = RunService.Heartbeat:Connect(function()
            updateText()
            task.wait(0.015) -- Adjust this value to change typing speed
        end)
        
        -- Auto-close after shorter delay (3s for success, 4s for error)
        task.delay(isError and 4 or 3, function()
            -- Disconnect typewriter if still running
            if typewriterConnection then
                typewriterConnection:Disconnect()
            end
            
            local fadeOut = TweenService:Create(notification, TweenInfo.new(0.2, Enum.EasingStyle.Quint), {
                BackgroundTransparency = 1,
                Size = UDim2.new(0, 0, 0, 30)
            })
            fadeOut:Play()
            
            local textFade = TweenService:Create(label, TweenInfo.new(0.2), {
                TextTransparency = 1
            })
            textFade:Play()
            
            local accentFade = TweenService:Create(accent, TweenInfo.new(0.2), {
                BackgroundTransparency = 1
            })
            accentFade:Play()
            
            fadeOut.Completed:Connect(function()
                notification:Destroy()
            end)
        end)
        
        return notification
    end
    
    local Arrow = Instance.new("TextLabel")
    Arrow.Name = "Arrow"
    Arrow.Text = ">"
    Arrow.Font = Enum.Font.Arcade
    Arrow.TextSize = 40
    Arrow.TextColor3 = Color3.fromRGB(0, 255, 0)
    Arrow.BackgroundTransparency = 1
    Arrow.Size = UDim2.new(0, 56, 0, 50)
    Arrow.Position = UDim2.new(0, 0, 0, -6)
    Arrow.Parent = MainFrame

    -- Blinking arrow animation
    local arrowBlink = TweenService:Create(Arrow, TweenInfo.new(0.8, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true), {
        TextTransparency = 0.5
    })
    arrowBlink:Play()

    local InputBox = Instance.new("TextBox")
    InputBox.Name = "InputBox"
    InputBox.PlaceholderText = "..."
    InputBox.Font = Enum.Font.Arcade
    InputBox.TextSize = 25
    InputBox.TextColor3 = Color3.fromRGB(0, 255, 0)
    InputBox.PlaceholderColor3 = Color3.fromRGB(0, 255, 0)
    InputBox.BackgroundTransparency = 1
    InputBox.TextXAlignment = Enum.TextXAlignment.Left
    InputBox.Size = UDim2.new(0, 102, 0, 44)
    InputBox.Position = UDim2.new(0, 40, 0, 0)
    InputBox.Parent = MainFrame

    -- Input box focus animations
    InputBox.Focused:Connect(function()
        clickSound:Play()
        local focusTween = TweenService:Create(InputBox, TweenInfo.new(0.2), {
            TextColor3 = Color3.fromRGB(0, 255, 255),
            PlaceholderColor3 = Color3.fromRGB(0, 255, 255)
        })
        focusTween:Play()
    end)

    InputBox.FocusLost:Connect(function()
        local unfocusTween = TweenService:Create(InputBox, TweenInfo.new(0.2), {
            TextColor3 = Color3.fromRGB(0, 255, 0),
            PlaceholderColor3 = Color3.fromRGB(0, 255, 0)
        })
        unfocusTween:Play()
    end)

    local VersionLabel = Instance.new("TextLabel")
    VersionLabel.Name = "VersionLabel"
    VersionLabel.Text = "V0.7"
    VersionLabel.TextSize = 10
    VersionLabel.TextTransparency = 0.6
    VersionLabel.TextColor3 = Color3.fromRGB(0, 0, 0)
    VersionLabel.BackgroundTransparency = 1
    VersionLabel.Size = UDim2.new(0, 26, 0, 18)
    VersionLabel.Position = UDim2.new(0, 8, 0, 44)
    VersionLabel.Parent = MainFrame

    -- Version label animation
    local versionPulse = TweenService:Create(VersionLabel, TweenInfo.new(2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true), {
        TextTransparency = 0.3
    })
    versionPulse:Play()

    -- Initial boot animation
    MainFrame.Size = UDim2.new(0, 0, 0, 44)
    MainFrame.BackgroundTransparency = 1
    Arrow.TextTransparency = 1
    InputBox.TextTransparency = 1
    VersionLabel.TextTransparency = 1

    local openTween = TweenService:Create(MainFrame, TweenInfo.new(0.5, Enum.EasingStyle.Quint), {
        Size = UDim2.new(0, 146, 0, 44),
        BackgroundTransparency = 0.2
    })
    openTween:Play()

    openTween.Completed:Connect(function()
        clickSound:Play()
        TweenService:Create(Arrow, TweenInfo.new(0.3), {TextTransparency = 0}):Play()
        TweenService:Create(InputBox, TweenInfo.new(0.3), {TextTransparency = 0}):Play()
        TweenService:Create(VersionLabel, TweenInfo.new(0.3), {TextTransparency = 0.6}):Play()
    end)

    -- Enhanced Help GUI with animations
    local function createHelpWindow()
        -- Create main frame with initial transparency
        local helpFrame = Instance.new("Frame")
        helpFrame.Name = "HelpFrame"
        helpFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
        helpFrame.BackgroundTransparency = 1
        helpFrame.BorderSizePixel = 0
        helpFrame.Size = UDim2.new(0.2, 0, 0.3, 0) -- Updated size
        helpFrame.Position = UDim2.new(0, 170, 0, -44) -- Updated position
        helpFrame.Parent = ScreenGui
        
        local helpCorner = Instance.new("UICorner")
        helpCorner.CornerRadius = UDim.new(0, 12)
        helpCorner.Parent = helpFrame
        
        -- Title bar with fade-in effect
        local titleBar = Instance.new("Frame")
        titleBar.Name = "TitleBar"
        titleBar.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
        titleBar.BackgroundTransparency = 1
        titleBar.Size = UDim2.new(1, 0, 0, 30)
        titleBar.Position = UDim2.new(0, 0, 0, 0)
        titleBar.Parent = helpFrame
        
        local titleCorner = Instance.new("UICorner")
        titleCorner.CornerRadius = UDim.new(0, 12)
        titleCorner.Parent = titleBar
        
        local titleText = Instance.new("TextLabel")
        titleText.Name = "TitleText"
        titleText.Text = "Commands :-)"
        titleText.Font = Enum.Font.Arcade
        titleText.TextSize = 18
        titleText.TextColor3 = Color3.fromRGB(0, 255, 0)
        titleText.TextTransparency = 1
        titleText.BackgroundTransparency = 1
        titleText.Size = UDim2.new(1, -40, 1, 0)
        titleText.Position = UDim2.new(0, 10, 0, 0)
        titleText.TextXAlignment = Enum.TextXAlignment.Left
        titleText.Parent = titleBar
        
        -- Close button with hover effect
        local closeButton = Instance.new("TextButton")
        closeButton.Name = "CloseButton"
        closeButton.Text = "X"
        closeButton.Font = Enum.Font.Arcade
        closeButton.TextSize = 18
        closeButton.TextColor3 = Color3.fromRGB(255, 0, 0)
        closeButton.TextTransparency = 1
        closeButton.BackgroundTransparency = 1
        closeButton.Size = UDim2.new(0, 30, 1, 0)
        closeButton.Position = UDim2.new(1, -30, 0, 0)
        closeButton.Parent = titleBar
        
        closeButton.MouseButton1Click:Connect(function()
            clickSound:Play()
            -- Close animation
            local closeAnim = TweenService:Create(helpFrame, TweenInfo.new(0.3, Enum.EasingStyle.Quint), {
                BackgroundTransparency = 1,
                Size = UDim2.new(0, 0, 0, 0),
                Position = UDim2.new(0.5, 0, 0.5, 0)
            })
            closeAnim:Play()
            closeAnim.Completed:Connect(function()
                helpFrame:Destroy()
            end)
        end)
        
        -- Hover effects for close button
        closeButton.MouseEnter:Connect(function()
            TweenService:Create(closeButton, TweenInfo.new(0.2), {
                TextColor3 = Color3.fromRGB(255, 100, 100)
            }):Play()
        end)
        
        closeButton.MouseLeave:Connect(function()
            TweenService:Create(closeButton, TweenInfo.new(0.2), {
                TextColor3 = Color3.fromRGB(255, 0, 0)
            }):Play()
        end)
        
        -- Scrolling frame for commands
        local scrollFrame = Instance.new("ScrollingFrame")
        scrollFrame.Name = "ScrollFrame"
        scrollFrame.BackgroundTransparency = 1
        scrollFrame.Size = UDim2.new(1, -20, 1, -40)
        scrollFrame.Position = UDim2.new(0, 10, 0, 40)
        scrollFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
        scrollFrame.AutomaticCanvasSize = Enum.AutomaticSize.Y
        scrollFrame.ScrollBarThickness = 5
        scrollFrame.ScrollBarImageColor3 = Color3.fromRGB(0, 255, 0)
        scrollFrame.ScrollBarImageTransparency = 1
        scrollFrame.Parent = helpFrame
        
        local layout = Instance.new("UIListLayout")
        layout.Padding = UDim.new(0, 10) -- Increased padding between commands
        layout.Parent = scrollFrame
        
        -- Add commands to help window with sequential animations
        local commandFrames = {}
        for _, cmd in ipairs(CommandOrder) do
            local data = Commands[cmd]
            local commandFrame = Instance.new("Frame")
            commandFrame.BackgroundTransparency = 1
            commandFrame.Size = UDim2.new(1, 0, 0, 0) -- Height will be automatic
            commandFrame.AutomaticSize = Enum.AutomaticSize.Y
            commandFrame.Parent = scrollFrame
            
            -- Create a string that shows the command and its aliases
            local aliasesText = ""
            if #data.aliases > 0 then
                aliasesText = " (" .. table.concat(data.aliases, "/") .. ")"
            end
            
            -- Command name with parameters and aliases
            local cmdText = Instance.new("TextLabel")
            cmdText.Name = "CmdText"
            if data.hasValue and data.hasPlayer then
                cmdText.Text = cmd .. aliasesText .. " <player> <" .. (data.valueName or "value") .. ">"
            elseif data.hasValue then
                cmdText.Text = cmd .. aliasesText .. " <" .. (data.valueName or "value") .. ">"
            elseif data.hasPlayer then
                cmdText.Text = cmd .. aliasesText .. " <player>"
            else
                cmdText.Text = cmd .. aliasesText
            end
            cmdText.Font = Enum.Font.Arcade
            cmdText.TextSize = 13
            cmdText.TextColor3 = Color3.fromRGB(0, 255, 255)
            cmdText.TextTransparency = 1
            cmdText.BackgroundTransparency = 1
            cmdText.TextXAlignment = Enum.TextXAlignment.Left
            cmdText.AutomaticSize = Enum.AutomaticSize.Y
            cmdText.Size = UDim2.new(1, 0, 0, 0)
            cmdText.Parent = commandFrame
            
            -- Description text (on new line)
            local descText = Instance.new("TextLabel")
            descText.Name = "DescText"
            descText.Text = data.desc
            descText.Font = Enum.Font.Arcade
            descText.TextSize = 14
            descText.TextColor3 = Color3.fromRGB(0, 255, 0)
            descText.TextTransparency = 1
            descText.BackgroundTransparency = 1
            descText.TextXAlignment = Enum.TextXAlignment.Left
            descText.TextWrapped = true -- Allow text to wrap
            descText.AutomaticSize = Enum.AutomaticSize.Y
            descText.Size = UDim2.new(1, 0, 0, 0)
            descText.Position = UDim2.new(0, 0, 0, 20) -- Position below command text
            descText.Parent = commandFrame
            
            table.insert(commandFrames, commandFrame)
        end
        
        -- Window open animation
        helpFrame.BackgroundTransparency = 1
        helpFrame.Size = UDim2.new(0, 10, 0, 10)
        
        local openAnim = TweenService:Create(helpFrame, TweenInfo.new(0.4, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
            BackgroundTransparency = 0.2,
            Size = UDim2.new(0.3, 0, 0.5, 0), -- Updated target size
            Position = UDim2.new(0, 170, 0, -44) -- Updated target position
        })
        openAnim:Play()
        
        openAnim.Completed:Connect(function()
            -- Fade in title bar
            TweenService:Create(titleBar, TweenInfo.new(0.3), {
                BackgroundTransparency = 0
            }):Play()
            
            -- Fade in title text
            TweenService:Create(titleText, TweenInfo.new(0.3), {
                TextTransparency = 0
            }):Play()
            
            -- Fade in close button
            TweenService:Create(closeButton, TweenInfo.new(0.3), {
                TextTransparency = 0
            }):Play()
            
            -- Fade in scrollbar
            TweenService:Create(scrollFrame, TweenInfo.new(0.3), {
                ScrollBarImageTransparency = 0.5
            }):Play()
            
            -- Sequential fade in for command entries
            for i, frame in ipairs(commandFrames) do
                task.spawn(function()
                    task.wait(i * 0.05)
                    -- Fade in command text
                    TweenService:Create(frame:FindFirstChild("CmdText"), TweenInfo.new(0.3), {
                        TextTransparency = 0
                    }):Play()
                    
                    -- Fade in description text
                    TweenService:Create(frame:FindFirstChild("DescText"), TweenInfo.new(0.3), {
                        TextTransparency = 0
                    }):Play()
                    
                    -- Add subtle hover effect for each command
                    frame.MouseEnter:Connect(function()
                        TweenService:Create(frame:FindFirstChild("CmdText"), TweenInfo.new(0.2), {
                            TextColor3 = Color3.fromRGB(0, 255, 255),
                            TextSize = 17
                        }):Play()
                    end)
                    
                    frame.MouseLeave:Connect(function()
                        TweenService:Create(frame:FindFirstChild("CmdText"), TweenInfo.new(0.2), {
                            TextColor3 = Color3.fromRGB(0, 255, 200),
                            TextSize = 16
                        }):Play()
                    end)
                end)
            end
        end)
        
        -- Make window draggable
        local dragging
        local dragInput
        local dragStart
        local startPos
        
        titleBar.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                dragging = true
                dragStart = input.Position
                startPos = helpFrame.Position
                
                input.Changed:Connect(function()
                    if input.UserInputState == Enum.UserInputState.End then
                        dragging = false
                    end
                end)
            end
        end)
        
        titleBar.InputChanged:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseMovement then
                dragInput = input
            end
        end)
        
        UserInputService.InputChanged:Connect(function(input)
            if input == dragInput and dragging then
                local delta = input.Position - dragStart
                helpFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X,
                                              startPos.Y.Scale, startPos.Y.Offset + delta.Y)
            end
        end)
        
        return helpFrame
    end

    -- Command handler
    InputBox.FocusLost:Connect(function(enterPressed)
        if enterPressed then
            clickSound:Play()
            
            -- Arrow flicker animation when Enter is pressed
            local flickerTween1 = TweenService:Create(Arrow, TweenInfo.new(0.1), {
                TextTransparency = 0.8
            })
            local flickerTween2 = TweenService:Create(Arrow, TweenInfo.new(0.1), {
                TextTransparency = 0
            })
            
            flickerTween1:Play()
            flickerTween1.Completed:Connect(function()
                flickerTween2:Play()
            end)
            
            local fullCommand = InputBox.Text
            InputBox.Text = ""
            
            -- Split command and arguments
            local parts = {}
            for part in string.gmatch(fullCommand, "%S+") do
                table.insert(parts, part:lower())
            end
            
            if #parts == 0 then return end
            
            local commandText = parts[1]
            local command = Commands[commandText]
            
            if command then
                -- Check if command expects inputs
                if command.hasValue or command.hasPlayer then
                    local playerName, value
                    local currentIndex = 2
                    
                    -- First check for player name if command expects it
                    if command.hasPlayer and #parts >= currentIndex then
                        playerName = parts[currentIndex]
                        currentIndex = currentIndex + 1
                    end
                    
                    -- Then check for value if command expects it
                    if command.hasValue and #parts >= currentIndex then
                        value = table.concat(parts, " ", currentIndex)
                    elseif command.hasValue then
                        -- Missing value
                        showNotification(string.format("Missing value for %s. Usage: %s%s%s", 
                            commandText, 
                            commandText,
                            command.hasPlayer and " <player>" or "",
                            command.hasValue and " <"..(command.valueName or "value")..">" or ""), true)
                        return
                    end
                    
                    -- Execute command with inputs
                    local success, result = pcall(function()
                        if command.hasPlayer and command.hasValue then
                            return command.exec(playerName, value)
                        elseif command.hasPlayer then
                            return command.exec(playerName)
                        elseif command.hasValue then
                            return command.exec(value)
                        end
                    end)
                    
                    if success then
                        if commandText ~= "cmds" then
                            showNotification(tostring(result), false)
                            
                            -- On PC, hide the GUI after command execution
                            if not isMobile() then
                                local closeTween = TweenService:Create(MainFrame, TweenInfo.new(0.3, Enum.EasingStyle.Quint), {
                                    Size = UDim2.new(0, 0, 0, 44),
                                    BackgroundTransparency = 1
                                })
                                closeTween:Play()
                                closeTween.Completed:Connect(function()
                                    ScreenGui.Enabled = false
                                end)
                            end
                        else
                            createHelpWindow()
                        end
                    else
                        showNotification("Command Error: "..tostring(result), true)
                    end
                else
                    -- Handle regular command without inputs
                    local success, result = pcall(command.exec)
                    if success then
                        if commandText == "cmds" then
                            createHelpWindow()
                        else
                            showNotification(tostring(result), false)
                            
                            -- On PC, hide the GUI after command execution
                            if not isMobile() then
                                local closeTween = TweenService:Create(MainFrame, TweenInfo.new(0.3, Enum.EasingStyle.Quint), {
                                    Size = UDim2.new(0, 0, 0, 44),
                                    BackgroundTransparency = 1
                                })
                                closeTween:Play()
                                closeTween.Completed:Connect(function()
                                    ScreenGui.Enabled = false
                                end)
                            end
                        end
                    else
                        showNotification("Command Error: "..tostring(result), true)
                    end
                end
            else
                -- Unknown command
                showNotification("Unknown command: "..commandText, true)
            end
        end
    end)

    -- Toggle GUI visibility with RightShift (with animation) - only on PC
    if not isMobile() then
        UserInputService.InputBegan:Connect(function(input, gameProcessed)
            if input.KeyCode == Enum.KeyCode.RightShift and not gameProcessed then
                clickSound:Play()
                if ScreenGui.Enabled then
                    -- Close animation
                    local closeTween = TweenService:Create(MainFrame, TweenInfo.new(0.3, Enum.EasingStyle.Quint), {
                        Size = UDim2.new(0, 0, 0, 44),
                        BackgroundTransparency = 1
                    })
                    closeTween:Play()
                    closeTween.Completed:Connect(function()
                        ScreenGui.Enabled = false
                    end)
                else
                    -- Open animation
                    ScreenGui.Enabled = true
                    MainFrame.Size = UDim2.new(0, 0, 0, 44)
                    local openTween = TweenService:Create(MainFrame, TweenInfo.new(0.3, Enum.EasingStyle.Quint), {
                        Size = UDim2.new(0, 146, 0, 44),
                        BackgroundTransparency = 0.2
                    })
                    openTween:Play()
                    
                    -- Focus the input box
                    task.wait(0.3)
                    InputBox:CaptureFocus()
                end
            end
        end)
    end

    -- Initial notification with delay
    task.delay(1.5, function()
        local notification = Instance.new("TextLabel")
        notification.Name = "Notification"
        notification.Text = "type 'cmds' for commands\n:D"
        notification.Font = Enum.Font.Arcade
        notification.TextSize = 15
        notification.TextColor3 = Color3.fromRGB(0, 255, 255)
        notification.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
        notification.BackgroundTransparency = 1
        notification.Size = UDim2.new(0, 200, 0, 40)
        notification.Position = UDim2.new(0, 20, 0, 69)
        notification.ZIndex = 10
        notification.Parent = ScreenGui
        
        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 15)
        corner.Parent = notification
        
        clickSound:Play()
        
        -- Fade in
        notification.BackgroundTransparency = 1
        notification.TextTransparency = 1
        local fadeIn = TweenService:Create(notification, TweenInfo.new(0.3), {
            BackgroundTransparency = 0.5,
            TextTransparency = 0
        })
        fadeIn:Play()
        
        -- Fade out after delay
        task.delay(3, function()
            local fadeOut = TweenService:Create(notification, TweenInfo.new(0.3), {
                TextTransparency = 1,
                BackgroundTransparency = 1
            })
            fadeOut:Play()
            fadeOut.Completed:Connect(function()
                notification:Destroy()
            end)
        end)
    end)
end

-- Initialize the GUI
initializeGUI()

-- Handle character respawns
localPlayer.CharacterAdded:Connect(function(newCharacter)
    character = newCharacter
    humanoid = character:WaitForChild("Humanoid")
    
    -- Make sure the GUI is properly parented after respawn
    if not ScreenGui.Parent then
        ScreenGui.Parent = localPlayer:WaitForChild("PlayerGui")
    end
    
    -- Reinitialize the GUI to ensure all connections are fresh
    initializeGUI()
end)

-- Initial parent assignment
ScreenGui.Parent = localPlayer:WaitForChild("PlayerGui")
